/* Generated by: CongoCC Parser Generator. MdxParser.java
*
* Copyright (c) 2023 Contributors to the Eclipse Foundation.
*
* This program and the accompanying materials are made
* available under the terms of the Eclipse Public License 2.0
* which is available at https://www.eclipse.org/legal/epl-2.0/
*
* SPDX-License-Identifier: EPL-2.0
*
* Contributors: see corresponding .ccc file
*/
package org.eclipse.daanse.mdx.parser.ccc;

import java.io.IOException;
import java.io.PrintStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.charset.Charset;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.Collections;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.ListIterator;
import java.util.concurrent.CancellationException;
import org.eclipse.daanse.mdx.parser.ccc.MdxLexer.LexicalState;
import org.eclipse.daanse.mdx.parser.ccc.Token.TokenType;
import static org.eclipse.daanse.mdx.parser.ccc.Token.TokenType.*;
import org.eclipse.daanse.mdx.parser.ccc.tree.ASTparseMdxStatement;
import org.eclipse.daanse.mdx.parser.ccc.tree.ASTparseDrillthroughStatement;
import org.eclipse.daanse.mdx.parser.ccc.tree.ASTparseExplainStatement;
import org.eclipse.daanse.mdx.parser.ccc.tree.ASTparseReturnItems;
import org.eclipse.daanse.mdx.parser.ccc.tree.ASTparseReturnItem;
import org.eclipse.daanse.mdx.parser.ccc.tree.ASTparseCreateCellCalculationBodyClause;
import org.eclipse.daanse.mdx.parser.ccc.tree.ASTparseMeasureBodyClause;
import org.eclipse.daanse.mdx.parser.ccc.tree.ASTparseSelectWithClause;
import org.eclipse.daanse.mdx.parser.ccc.tree.ASTparseSelectStatement;
import org.eclipse.daanse.mdx.parser.ccc.tree.ASTparseSelectSubcubeClause;
import org.eclipse.daanse.mdx.parser.ccc.tree.ASTparseSelectSubcubeClauseName;
import org.eclipse.daanse.mdx.parser.ccc.tree.ASTparseSelectSubcubeClauseStatement;
import org.eclipse.daanse.mdx.parser.ccc.tree.ASTparseSelectQueryAsteriskClause;
import org.eclipse.daanse.mdx.parser.ccc.tree.ASTparseSelectQueryAxesClause;
import org.eclipse.daanse.mdx.parser.ccc.tree.ASTparseSelectSlicerAxisClause;
import org.eclipse.daanse.mdx.parser.ccc.tree.ASTparseSelectCellPropertyListClause;
import org.eclipse.daanse.mdx.parser.ccc.tree.ASTparseCreateMemberBodyClause;
import org.eclipse.daanse.mdx.parser.ccc.tree.ASTparseMemberPropertyDefinition;
import org.eclipse.daanse.mdx.parser.ccc.tree.ASTparseFormulaExpression;
import org.eclipse.daanse.mdx.parser.ccc.tree.ASTparseExpression;
import org.eclipse.daanse.mdx.parser.ccc.tree.ASTparseExpressionOrEmpty;
import org.eclipse.daanse.mdx.parser.ccc.tree.ASTexpOrEmptyList;
import org.eclipse.daanse.mdx.parser.ccc.tree.ASTexpList;
import org.eclipse.daanse.mdx.parser.ccc.tree.ASTparseExpressionEof;
import org.eclipse.daanse.mdx.parser.ccc.tree.ASTparseIdentifier;
import org.eclipse.daanse.mdx.parser.ccc.tree.ASTparseNameObjectIdentifier;
import org.eclipse.daanse.mdx.parser.ccc.tree.ASTparseKeyIdentifier;
import org.eclipse.daanse.mdx.parser.ccc.tree.ASTparseAmpId;
import org.eclipse.daanse.mdx.parser.ccc.tree.ASTparseKeyword;
import org.eclipse.daanse.mdx.parser.ccc.tree.ASTparseCompoundId;
import org.eclipse.daanse.mdx.parser.ccc.tree.ASTparseUnaliasedExpression;
import org.eclipse.daanse.mdx.parser.ccc.tree.ASTparseTerm5;
import org.eclipse.daanse.mdx.parser.ccc.tree.ASTparseTerm4;
import org.eclipse.daanse.mdx.parser.ccc.tree.ASTparseTerm3;
import org.eclipse.daanse.mdx.parser.ccc.tree.ASTparseTerm2;
import org.eclipse.daanse.mdx.parser.ccc.tree.ASTparseTerm;
import org.eclipse.daanse.mdx.parser.ccc.tree.ASTparseFactor;
import org.eclipse.daanse.mdx.parser.ccc.tree.ASTparsePrimary;
import org.eclipse.daanse.mdx.parser.ccc.tree.ASTobjectIdentifierOrFuncall;
import org.eclipse.daanse.mdx.parser.ccc.tree.ASTparseNumericLiteral;
import org.eclipse.daanse.mdx.parser.ccc.tree.ASTparseAtom;
import org.eclipse.daanse.mdx.parser.ccc.tree.ASTparseCaseExpression;
import org.eclipse.daanse.mdx.parser.ccc.tree.ASTparseCreateSetBodyClause;
import org.eclipse.daanse.mdx.parser.ccc.tree.ASTparseSelectDimensionPropertyListClause;
import org.eclipse.daanse.mdx.parser.ccc.tree.ASTparseRefreshStatement;
import org.eclipse.daanse.mdx.parser.ccc.tree.ASTparseSelectQueryAxisClause;
import org.eclipse.daanse.mdx.model.record.select.SelectSubcubeClauseStatementR;
import org.eclipse.daanse.mdx.model.record.expression.SymbolLiteralR;
import java.util.Optional;
import org.eclipse.daanse.mdx.model.api.expression.Expression;
import org.eclipse.daanse.mdx.model.record.ExplainStatementR;
import org.eclipse.daanse.mdx.model.record.select.CreateMemberBodyClauseR;
import org.eclipse.daanse.mdx.model.record.select.MemberPropertyDefinitionR;
import org.eclipse.daanse.mdx.model.record.expression.CompoundIdR;
import org.eclipse.daanse.mdx.model.record.expression.FormulaExpressionR;
import org.eclipse.daanse.mdx.model.api.expression.FormulaExpression;
import org.eclipse.daanse.mdx.model.api.select.SelectSubcubeClauseName;
import org.eclipse.daanse.mdx.model.record.select.MeasureBodyClauseR;
import org.eclipse.daanse.mdx.model.api.select.Axis;
import org.eclipse.daanse.mdx.model.record.expression.StringLiteralR;
import java.util.LinkedList;
import org.eclipse.daanse.mdx.model.api.MdxStatement;
import org.eclipse.daanse.mdx.model.api.select.SelectSubcubeClauseStatement;
import org.eclipse.daanse.mdx.model.api.select.SelectQueryAxesClause;
import org.eclipse.daanse.mdx.model.api.DrillthroughStatement;
import org.eclipse.daanse.mdx.model.api.ReturnItem;
import org.eclipse.daanse.mdx.model.api.select.SelectSubcubeClause;
import org.eclipse.daanse.mdx.model.api.select.SelectQueryClause;
import org.eclipse.daanse.mdx.model.record.expression.NullLiteralR;
import org.eclipse.daanse.mdx.model.record.select.SelectSlicerAxisClauseR;
import org.eclipse.daanse.mdx.model.api.select.MemberPropertyDefinition;
import org.eclipse.daanse.mdx.model.record.select.AxisR;
import org.eclipse.daanse.mdx.model.record.ReturnItemR;
import org.eclipse.daanse.mdx.model.api.SelectStatement;
import org.eclipse.daanse.mdx.model.api.select.SelectDimensionPropertyListClause;
import org.eclipse.daanse.mdx.model.record.select.SelectSubcubeClauseNameR;
import org.eclipse.daanse.mdx.model.record.select.SelectQueryAsteriskClauseR;
import org.eclipse.daanse.mdx.model.record.expression.CallExpressionR;
import org.eclipse.daanse.mdx.model.record.select.SelectQueryAxisClauseR;
import org.eclipse.daanse.mdx.model.api.select.MeasureBodyClause;
import org.eclipse.daanse.mdx.model.api.select.SelectSlicerAxisClause;
import org.eclipse.daanse.mdx.model.record.select.SelectQueryEmptyClauseR;
import org.eclipse.daanse.mdx.model.api.select.CreateCellCalculationBodyClause;
import org.eclipse.daanse.mdx.model.record.DrillthroughStatementR;
import org.eclipse.daanse.mdx.model.api.select.SelectWithClause;
import org.eclipse.daanse.mdx.model.api.expression.CallExpression;
import org.eclipse.daanse.mdx.model.record.RefreshStatementR;
import org.eclipse.daanse.mdx.model.record.select.CreateSetBodyClauseR;
import org.eclipse.daanse.mdx.model.api.expression.ObjectIdentifier;
import org.eclipse.daanse.mdx.model.record.expression.NumericLiteralR;
import org.eclipse.daanse.mdx.model.record.select.SelectQueryAxesClauseR;
import org.eclipse.daanse.mdx.model.api.RefreshStatement;
import org.eclipse.daanse.mdx.model.api.select.CreateMemberBodyClause;
import org.eclipse.daanse.mdx.model.api.select.SelectCellPropertyListClause;
import java.math.BigDecimal;
import org.eclipse.daanse.mdx.model.api.expression.NameObjectIdentifier;
import org.eclipse.daanse.mdx.model.record.select.SelectCellPropertyListClauseR;
import org.eclipse.daanse.mdx.model.record.select.SelectDimensionPropertyListClauseR;
import org.eclipse.daanse.mdx.model.api.select.CreateSetBodyClause;
import java.util.List;
import org.eclipse.daanse.mdx.model.api.select.SelectQueryAsteriskClause;
import org.eclipse.daanse.mdx.model.api.ExplainStatement;
import org.eclipse.daanse.mdx.model.api.select.SelectQueryAxisClause;
import org.eclipse.daanse.mdx.model.api.expression.CompoundId;
import org.eclipse.daanse.mdx.model.record.expression.KeyObjectIdentifierR;
import org.eclipse.daanse.mdx.model.record.SelectStatementR;
import org.eclipse.daanse.mdx.model.record.expression.NameObjectIdentifierR;
import org.eclipse.daanse.mdx.model.api.expression.KeyObjectIdentifier;
import org.eclipse.daanse.mdx.model.api.expression.NumericLiteral;


public class MdxParser {
    static final int UNLIMITED = Integer.MAX_VALUE;
    // The last token successfully "consumed"
    Token lastConsumedToken;
    private TokenType nextTokenType;
    private Token currentLookaheadToken;
    private int remainingLookahead;
    private boolean hitFailure, passedPredicate;
    private String currentlyParsedProduction, currentLookaheadProduction;
    private int lookaheadRoutineNesting, passedPredicateThreshold = -1;
    EnumSet<TokenType> outerFollowSet;
    private boolean legacyGlitchyLookahead = false;
    private final Token DUMMY_START_TOKEN = new Token();
    private boolean cancelled;

    public void cancel() {
        cancelled = true;
    }

    public boolean isCancelled() {
        return cancelled;
    }

    /** Generated Lexer. */
    public MdxLexer token_source;

    public void setInputSource(String inputSource) {
        token_source.setInputSource(inputSource);
    }

    String getInputSource() {
        return token_source.getInputSource();
    }

    //=================================
    // Generated constructors
    //=================================
    public MdxParser(String inputSource, CharSequence content) {
        this(new MdxLexer(inputSource, content));
    }

    public MdxParser(CharSequence content) {
        this("input", content);
    }

    /**
    * @param inputSource just the name of the input source (typically the filename) that
    * will be used in error messages and so on.
    * @param path The location (typically the filename) from which to get the input to parse
    */
    public MdxParser(String inputSource, Path path) throws IOException {
        this(inputSource, TokenSource.stringFromBytes(Files.readAllBytes(path)));
    }

    public MdxParser(String inputSource, Path path, Charset charset) throws IOException {
        this(inputSource, TokenSource.stringFromBytes(Files.readAllBytes(path), charset));
    }

    /**
    * @param path The location (typically the filename) from which to get the input to parse
    */
    public MdxParser(Path path) throws IOException {
        this(path.toString(), path);
    }

    /** Constructor with user supplied Lexer. */
    public MdxParser(MdxLexer lexer) {
        token_source = lexer;
        lastConsumedToken = DUMMY_START_TOKEN;
        lastConsumedToken.setTokenSource(lexer);
    }

    /**
    * Set the starting line/column for location reporting.
    * By default, this is 1,1.
    */
    public void setStartingPos(int startingLine, int startingColumn) {
        token_source.setStartingPos(startingLine, startingColumn);
    }

    // If the next token is cached, it returns that
    // Otherwise, it goes to the token_source, i.e. the Lexer.
    final private Token nextToken(final Token tok) {
        Token result = token_source.getNextToken(tok);
        while (result.isUnparsed()) {
            result = token_source.getNextToken(result);
        }
        nextTokenType = null;
        return result;
    }

    /**
    * @return the next Token off the stream. This is the same as #getToken(1)
    */
    final public Token getNextToken() {
        return getToken(1);
    }

    /**
    * @param index how many tokens to look ahead
    * @return the specific regular (i.e. parsed) Token index ahead/behind in the stream.
    * If we are in a lookahead, it looks ahead from the currentLookaheadToken
    * Otherwise, it is the lastConsumedToken. If you pass in a negative
    * number it goes backward.
    */
    final public Token getToken(final int index) {
        Token t = currentLookaheadToken == null ? lastConsumedToken : currentLookaheadToken;
        for (int i = 0; i < index; i++) {
            t = nextToken(t);
        }
        for (int i = 0; i > index; i--) {
            t = t.getPrevious();
            if (t == null) break;
        }
        return t;
    }

    private final TokenType nextTokenType() {
        if (nextTokenType == null) {
            nextTokenType = nextToken(lastConsumedToken).getType();
        }
        return nextTokenType;
    }

    boolean activateTokenTypes(TokenType...types) {
        if (token_source.activeTokenTypes == null) return false;
        boolean result = false;
        for (TokenType tt : types) {
            result |= token_source.activeTokenTypes.add(tt);
        }
        if (result) {
            token_source.reset(getToken(0));
            nextTokenType = null;
        }
        return result;
    }

    boolean deactivateTokenTypes(TokenType...types) {
        boolean result = false;
        if (token_source.activeTokenTypes == null) {
            token_source.activeTokenTypes = EnumSet.allOf(TokenType.class);
        }
        for (TokenType tt : types) {
            result |= token_source.activeTokenTypes.remove(tt);
        }
        if (result) {
            token_source.reset(getToken(0));
            nextTokenType = null;
        }
        return result;
    }

    private static HashMap<TokenType[], EnumSet<TokenType>> enumSetCache = new HashMap<>();

    private static EnumSet<TokenType> tokenTypeSet(TokenType first, TokenType...rest) {
        TokenType[] key = new TokenType[1 + rest.length];
        key[0] = first;
        if (rest.length > 0) {
            System.arraycopy(rest, 0, key, 1, rest.length);
        }
        Arrays.sort(key);
        if (enumSetCache.containsKey(key)) {
            return enumSetCache.get(key);
        }
        EnumSet<TokenType> result = (rest.length == 0) ? EnumSet.of(first) : EnumSet.of(first, rest);
        enumSetCache.put(key, result);
        return result;
    }

    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:407:1
    final public
    // ----------------------------------------------------------------------------
    // MDX Statement
    //
    // <statement> ::= <selectStatement>
    //                   | <drillthroughStatement>
    //                   | <explainStatement>
    //
    // <selectStatement> ::= [WITH <formulaSpecification>]
    //                         SELECT [<SelectQueryAxisClause>
    //                                [, <SelectQueryAxisClause>...]]
    //                         FROM [<cubeSpecification>]
    //                         [WHERE <slicerSpecification>]
    //                         [<cellProps>]
    //
    // <drillthroughStatment> ::=
    //     DRILLTHROUGH
    //     [ MAXROWS <count> ]
    //     [ FIRSTROWSET <count> ]
    //     <selectStatement>
    //     [ RETURN <memberOrAttribute> [, <memberOrAttribute>...] ]
    //
    // <explainStatement> ::=
    //     EXPLAIN PLAN FOR ( <selectStatement> | <drillthroughStatement> )
    //
    MdxStatement parseMdxStatement() {
        if (cancelled) throw new CancellationException();
        String prevProduction = currentlyParsedProduction;
        this.currentlyParsedProduction = "parseMdxStatement";
        ASTparseMdxStatement thisProduction = null;
        if (buildTree) {
            thisProduction = new ASTparseMdxStatement();
            openNodeScope(thisProduction);
        }
        MdxStatement mdxStatement = null;
        ParseException parseException2 = null;
        int callStackSize3 = parsingStack.size();
        try {
            // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:411:3
            pushOntoCallStack("parseMdxStatement", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 411, 3);
            try {
                mdxStatement = parseSelectStatement();
            } finally {
                popCallStack();
            }
            // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:424:3
            consumeToken(EOF);
            // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:425:3
            return mdxStatement;
        } catch (ParseException e) {
            parseException2 = e;
            throw e;
        } finally {
            restoreCallStack(callStackSize3);
            if (thisProduction != null) {
                if (parseException2 == null) {
                    closeNodeScope(thisProduction, nodeArity() > 1);
                } else {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction = prevProduction;
        }
    }

    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:431:1
    final public DrillthroughStatement parseDrillthroughStatement() {
        if (cancelled) throw new CancellationException();
        String prevProduction = currentlyParsedProduction;
        this.currentlyParsedProduction = "parseDrillthroughStatement";
        ASTparseDrillthroughStatement thisProduction = null;
        if (buildTree) {
            thisProduction = new ASTparseDrillthroughStatement();
            openNodeScope(thisProduction);
        }
        SelectStatement selectStatement = null;
        List<ReturnItem> returnItems = null;
        Optional<Integer> maxRows = Optional.ofNullable(null);
        Optional<Integer> firstRowSet = Optional.ofNullable(null);
        ParseException parseException18 = null;
        int callStackSize19 = parsingStack.size();
        try {
            // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:438:3
            consumeToken(DRILLTHROUGH);
            // Code for ZeroOrOne specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:439:3
            if (nextTokenType() == MAXROWS) {
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:440:5
                consumeToken(MAXROWS);
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:440:17
                consumeToken(UNSIGNED_INTEGER_LITERAL);
                // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:441:5
                maxRows = Optional.of(Integer.valueOf(getToken(0).getImage()));
            }
            // Code for ZeroOrOne specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:445:3
            if (nextTokenType() == FIRSTROWSET) {
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:446:5
                consumeToken(FIRSTROWSET);
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:446:21
                consumeToken(UNSIGNED_INTEGER_LITERAL);
                // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:447:5
                firstRowSet = Optional.of(Integer.valueOf(getToken(0).getImage()));
            }
            // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:451:3
            pushOntoCallStack("parseDrillthroughStatement", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 451, 3);
            try {
                selectStatement = parseSelectStatement();
            } finally {
                popCallStack();
            }
            // Code for ZeroOrOne specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:452:3
            if (nextTokenType() == RETURN) {
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:453:5
                consumeToken(RETURN);
                // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:453:16
                pushOntoCallStack("parseDrillthroughStatement", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 453, 16);
                try {
                    returnItems = parseReturnItems();
                } finally {
                    popCallStack();
                }
            }
            // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:455:3
            return new DrillthroughStatementR(maxRows, firstRowSet, selectStatement, returnItems);
        } catch (ParseException e) {
            parseException18 = e;
            throw e;
        } finally {
            restoreCallStack(callStackSize19);
            if (thisProduction != null) {
                if (parseException18 == null) {
                    closeNodeScope(thisProduction, nodeArity() > 1);
                } else {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction = prevProduction;
        }
    }

    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:460:1
    final public ExplainStatement parseExplainStatement() {
        if (cancelled) throw new CancellationException();
        String prevProduction = currentlyParsedProduction;
        this.currentlyParsedProduction = "parseExplainStatement";
        ASTparseExplainStatement thisProduction = null;
        if (buildTree) {
            thisProduction = new ASTparseExplainStatement();
            openNodeScope(thisProduction);
        }
        MdxStatement mdxStatement = null;
        ParseException parseException90 = null;
        int callStackSize91 = parsingStack.size();
        try {
            // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:464:3
            consumeToken(EXPLAIN);
            // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:464:15
            consumeToken(PLAN);
            // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:464:23
            consumeToken(FOR);
            if (nextTokenType() == SELECT || nextTokenType == WITH) {
                // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:466:5
                pushOntoCallStack("parseExplainStatement", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 466, 5);
                try {
                    mdxStatement = parseSelectStatement();
                } finally {
                    popCallStack();
                }
            } else if (nextTokenType() == DRILLTHROUGH) {
                // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:468:5
                pushOntoCallStack("parseExplainStatement", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 468, 5);
                try {
                    mdxStatement = parseDrillthroughStatement();
                } finally {
                    popCallStack();
                }
            } else {
                pushOntoCallStack("parseExplainStatement", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 466, 5);
                throw new ParseException(lastConsumedToken, first_set$Grammer_ccc$466$5, parsingStack);
            }
            // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:470:3
            return new ExplainStatementR(mdxStatement);
        } catch (ParseException e) {
            parseException90 = e;
            throw e;
        } finally {
            restoreCallStack(callStackSize91);
            if (thisProduction != null) {
                if (parseException90 == null) {
                    closeNodeScope(thisProduction, nodeArity() > 1);
                } else {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction = prevProduction;
        }
    }

    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:476:1
    final public List<ReturnItem> parseReturnItems() {
        if (cancelled) throw new CancellationException();
        String prevProduction = currentlyParsedProduction;
        this.currentlyParsedProduction = "parseReturnItems";
        ASTparseReturnItems thisProduction = null;
        if (buildTree) {
            thisProduction = new ASTparseReturnItems();
            openNodeScope(thisProduction);
        }
        List<ReturnItem> returnItems = new LinkedList<ReturnItem>();
        ReturnItem item;
        ParseException parseException131 = null;
        int callStackSize132 = parsingStack.size();
        try {
            // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:481:3
            pushOntoCallStack("parseReturnItems", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 481, 3);
            try {
                item = parseReturnItem();
            } finally {
                popCallStack();
            }
            // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:482:3
            returnItems.add(item);
            // Code for ZeroOrMore specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:485:3
            while (true) {
                if (!(nextTokenType() == COMMA)) break;
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:486:5
                consumeToken(COMMA);
                // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:486:15
                pushOntoCallStack("parseReturnItems", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 486, 15);
                try {
                    item = parseReturnItem();
                } finally {
                    popCallStack();
                }
                // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:487:5
                returnItems.add(item);
            }
            // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:491:3
            return returnItems;
        } catch (ParseException e) {
            parseException131 = e;
            throw e;
        } finally {
            restoreCallStack(callStackSize132);
            if (thisProduction != null) {
                if (parseException131 == null) {
                    closeNodeScope(thisProduction, nodeArity() > 1);
                } else {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction = prevProduction;
        }
    }

    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:497:1
    final public ReturnItem parseReturnItem() {
        if (cancelled) throw new CancellationException();
        String prevProduction = currentlyParsedProduction;
        this.currentlyParsedProduction = "parseReturnItem";
        ASTparseReturnItem thisProduction = null;
        if (buildTree) {
            thisProduction = new ASTparseReturnItem();
            openNodeScope(thisProduction);
        }
        CompoundId compoundId;
        ParseException parseException167 = null;
        int callStackSize168 = parsingStack.size();
        try {
            // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:501:3
            pushOntoCallStack("parseReturnItem", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 501, 3);
            try {
                compoundId = parseCompoundId();
            } finally {
                popCallStack();
            }
            // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:502:3
            return new ReturnItemR(compoundId);
        } catch (ParseException e) {
            parseException167 = e;
            throw e;
        } finally {
            restoreCallStack(callStackSize168);
            if (thisProduction != null) {
                if (parseException167 == null) {
                    closeNodeScope(thisProduction, nodeArity() > 1);
                } else {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction = prevProduction;
        }
    }

    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:509:1
    final public
    //https://learn.microsoft.com/en-us/sql/mdx/mdx-data-definition-create-cell-calculation?view=sql-server-ver16
    CreateCellCalculationBodyClause parseCreateCellCalculationBodyClause() {
        if (cancelled) throw new CancellationException();
        String prevProduction = currentlyParsedProduction;
        this.currentlyParsedProduction = "parseCreateCellCalculationBodyClause";
        ASTparseCreateCellCalculationBodyClause thisProduction = null;
        if (buildTree) {
            thisProduction = new ASTparseCreateCellCalculationBodyClause();
            openNodeScope(thisProduction);
        }
        CreateCellCalculationBodyClause createCellCalculationBC = null;
        ParseException parseException179 = null;
        int callStackSize180 = parsingStack.size();
        try {
            // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:513:2
            consumeToken(NOT);
            // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:513:7
            consumeToken(NOT);
            // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:513:12
            consumeToken(NOT);
            // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:513:17
            consumeToken(NOT);
            // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:513:22
            consumeToken(NOT);
            // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:513:27
            consumeToken(NOT);
            // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:513:32
            consumeToken(NOT);
            // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:514:3
            return createCellCalculationBC;
        } catch (ParseException e) {
            parseException179 = e;
            throw e;
        } finally {
            restoreCallStack(callStackSize180);
            if (thisProduction != null) {
                if (parseException179 == null) {
                    closeNodeScope(thisProduction, nodeArity() > 1);
                } else {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction = prevProduction;
        }
    }

    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:520:1
    final public
    // https://learn.microsoft.com/en-us/analysis-services/multidimensional-models/mdx/mdx-building-measures?view=asallproducts-allversions
    MeasureBodyClause parseMeasureBodyClause() {
        if (cancelled) throw new CancellationException();
        String prevProduction = currentlyParsedProduction;
        this.currentlyParsedProduction = "parseMeasureBodyClause";
        ASTparseMeasureBodyClause thisProduction = null;
        if (buildTree) {
            thisProduction = new ASTparseMeasureBodyClause();
            openNodeScope(thisProduction);
        }
        ParseException parseException215 = null;
        int callStackSize216 = parsingStack.size();
        try {
            // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:523:3
            consumeToken(NOT);
            // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:523:8
            consumeToken(NOT);
            // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:523:13
            consumeToken(NOT);
            // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:523:18
            consumeToken(NOT);
            // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:523:23
            consumeToken(NOT);
            // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:523:28
            consumeToken(NOT);
            // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:523:33
            consumeToken(NOT);
            // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:524:3
            return new MeasureBodyClauseR();
        } catch (ParseException e) {
            parseException215 = e;
            throw e;
        } finally {
            restoreCallStack(callStackSize216);
            if (thisProduction != null) {
                if (parseException215 == null) {
                    closeNodeScope(thisProduction, nodeArity() > 1);
                } else {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction = prevProduction;
        }
    }

    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:531:1
    final public
    // https://docs.oracle.com/cd/E57185_01/ESBTR/mdx_grammar_rules.html
    SelectWithClause parseSelectWithClause() {
        if (cancelled) throw new CancellationException();
        String prevProduction = currentlyParsedProduction;
        this.currentlyParsedProduction = "parseSelectWithClause";
        ASTparseSelectWithClause thisProduction = null;
        if (buildTree) {
            thisProduction = new ASTparseSelectWithClause();
            openNodeScope(thisProduction);
        }
        SelectWithClause selectWithClause = null;
        ParseException parseException251 = null;
        int callStackSize252 = parsingStack.size();
        try {
            if (nextTokenType() == CELL) {
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:535:5
                consumeToken(CELL);
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:535:12
                consumeToken(CALCULATION);
                // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:535:26
                pushOntoCallStack("parseSelectWithClause", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 535, 26);
                try {
                    selectWithClause = parseCreateCellCalculationBodyClause();
                } finally {
                    popCallStack();
                }
            } else if (nextTokenType() == MEMBER || nextTokenType == CALCULATED) {
                // Code for ZeroOrOne specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:536:5
                if (nextTokenType() == CALCULATED) {
                    // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:536:6
                    consumeToken(CALCULATED);
                }
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:536:21
                consumeToken(MEMBER);
                // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:536:32
                pushOntoCallStack("parseSelectWithClause", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 536, 32);
                try {
                    selectWithClause = parseCreateMemberBodyClause();
                } finally {
                    popCallStack();
                }
            } else if (nextTokenType() == SET) {
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:537:5
                consumeToken(SET);
                // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:537:13
                pushOntoCallStack("parseSelectWithClause", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 537, 13);
                try {
                    selectWithClause = parseCreateSetBodyClause();
                } finally {
                    popCallStack();
                }
            } else if (nextTokenType() == MEASURE) {
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:538:5
                consumeToken(MEASURE);
                // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:538:15
                pushOntoCallStack("parseSelectWithClause", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 538, 15);
                try {
                    selectWithClause = parseMeasureBodyClause();
                } finally {
                    popCallStack();
                }
            } else {
                pushOntoCallStack("parseSelectWithClause", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 535, 5);
                throw new ParseException(lastConsumedToken, first_set$Grammer_ccc$535$5, parsingStack);
            }
            // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:540:3
            return selectWithClause;
        } catch (ParseException e) {
            parseException251 = e;
            throw e;
        } finally {
            restoreCallStack(callStackSize252);
            if (thisProduction != null) {
                if (parseException251 == null) {
                    closeNodeScope(thisProduction, nodeArity() > 1);
                } else {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction = prevProduction;
        }
    }

    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:546:1
    final public
    //https://learn.microsoft.com/en-us/sql/mdx/mdx-data-manipulation-select?view=sql-server-ver16
    SelectStatement parseSelectStatement() {
        if (cancelled) throw new CancellationException();
        String prevProduction = currentlyParsedProduction;
        this.currentlyParsedProduction = "parseSelectStatement";
        ASTparseSelectStatement thisProduction = null;
        if (buildTree) {
            thisProduction = new ASTparseSelectStatement();
            openNodeScope(thisProduction);
        }
        List<SelectWithClause> selectWithClauses = new LinkedList<SelectWithClause>();
        SelectQueryClause selectQueryClause = null;
        SelectSubcubeClause selectSubcubeClause = null;
        Optional<SelectSlicerAxisClause> selectSlicerAxisClause = Optional.empty();
        SelectCellPropertyListClause selectCellPropertyListClause = null;
        SelectWithClause selectWithClause = null;
        ParseException parseException328 = null;
        int callStackSize329 = parsingStack.size();
        try {
            // Code for ZeroOrOne specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:555:3
            if (nextTokenType() == WITH) {
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:556:5
                consumeToken(WITH);
                // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:557:7
                pushOntoCallStack("parseSelectStatement", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 557, 7);
                try {
                    selectWithClause = parseSelectWithClause();
                } finally {
                    popCallStack();
                }
                // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:558:5
                selectWithClauses.add(selectWithClause);
                // Code for ZeroOrMore specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:561:5
                while (true) {
                    if (!(first_set$Grammer_ccc$562$8.contains(nextTokenType()))) break;
                    // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:562:8
                    pushOntoCallStack("parseSelectStatement", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 562, 8);
                    try {
                        selectWithClause = parseSelectWithClause();
                    } finally {
                        popCallStack();
                    }
                    // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:563:7
                    selectWithClauses.add(selectWithClause);
                }
            }
            // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:569:3
            consumeToken(SELECT);
            if (nextTokenType() == ASTERISK) {
                // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:571:5
                pushOntoCallStack("parseSelectStatement", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 571, 5);
                try {
                    selectQueryClause = parseSelectQueryAsteriskClause();
                } finally {
                    popCallStack();
                }
            } else if (first_set$Grammer_ccc$573$5.contains(nextTokenType())) {
                // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:573:5
                pushOntoCallStack("parseSelectStatement", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 573, 5);
                try {
                    selectQueryClause = parseSelectQueryAxesClause();
                } finally {
                    popCallStack();
                }
            } else {
                // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:575:5
                selectQueryClause = new SelectQueryEmptyClauseR();
            }
            // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:579:3
            consumeToken(FROM);
            // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:579:12
            pushOntoCallStack("parseSelectStatement", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 579, 12);
            try {
                selectSubcubeClause = parseSelectSubcubeClause();
            } finally {
                popCallStack();
            }
            // Code for ZeroOrOne specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:580:3
            if (nextTokenType() == WHERE) {
                // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:581:5
                pushOntoCallStack("parseSelectStatement", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 581, 5);
                try {
                    selectSlicerAxisClause = parseSelectSlicerAxisClause();
                } finally {
                    popCallStack();
                }
            }
            // Code for ZeroOrOne specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:583:3
            if (nextTokenType() == CELL || nextTokenType == PROPERTIES) {
                // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:584:5
                pushOntoCallStack("parseSelectStatement", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 584, 5);
                try {
                    selectCellPropertyListClause = parseSelectCellPropertyListClause();
                } finally {
                    popCallStack();
                }
            }
            // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:586:3
            return new SelectStatementR(selectWithClauses, selectQueryClause, selectSubcubeClause, selectSlicerAxisClause, Optional.ofNullable(selectCellPropertyListClause));
        } catch (ParseException e) {
            parseException328 = e;
            throw e;
        } finally {
            restoreCallStack(callStackSize329);
            if (thisProduction != null) {
                if (parseException328 == null) {
                    closeNodeScope(thisProduction, nodeArity() > 1);
                } else {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction = prevProduction;
        }
    }

    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:592:1
    final public SelectSubcubeClause parseSelectSubcubeClause() {
        if (cancelled) throw new CancellationException();
        String prevProduction = currentlyParsedProduction;
        this.currentlyParsedProduction = "parseSelectSubcubeClause";
        ASTparseSelectSubcubeClause thisProduction = null;
        if (buildTree) {
            thisProduction = new ASTparseSelectSubcubeClause();
            openNodeScope(thisProduction);
        }
        SelectSubcubeClause selectSubcubeClause = null;
        ParseException parseException437 = null;
        int callStackSize438 = parsingStack.size();
        try {
            if (first_set$Grammer_ccc$597$5.contains(nextTokenType())) {
                // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:597:5
                pushOntoCallStack("parseSelectSubcubeClause", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 597, 5);
                try {
                    selectSubcubeClause = parseSelectSubcubeClauseName();
                } finally {
                    popCallStack();
                }
            } else if (nextTokenType() == LPAREN) {
                // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:599:5
                pushOntoCallStack("parseSelectSubcubeClause", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 599, 5);
                try {
                    selectSubcubeClause = parseSelectSubcubeClauseStatement();
                } finally {
                    popCallStack();
                }
            } else {
                pushOntoCallStack("parseSelectSubcubeClause", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 597, 5);
                throw new ParseException(lastConsumedToken, first_set$Grammer_ccc$597$5$, parsingStack);
            }
            // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:601:3
            return selectSubcubeClause;
        } catch (ParseException e) {
            parseException437 = e;
            throw e;
        } finally {
            restoreCallStack(callStackSize438);
            if (thisProduction != null) {
                if (parseException437 == null) {
                    closeNodeScope(thisProduction, nodeArity() > 1);
                } else {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction = prevProduction;
        }
    }

    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:607:1
    final public SelectSubcubeClauseName parseSelectSubcubeClauseName() {
        if (cancelled) throw new CancellationException();
        String prevProduction = currentlyParsedProduction;
        this.currentlyParsedProduction = "parseSelectSubcubeClauseName";
        ASTparseSelectSubcubeClauseName thisProduction = null;
        if (buildTree) {
            thisProduction = new ASTparseSelectSubcubeClauseName();
            openNodeScope(thisProduction);
        }
        NameObjectIdentifier nameObjectIdentifier;
        ParseException parseException466 = null;
        int callStackSize467 = parsingStack.size();
        try {
            // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:611:3
            pushOntoCallStack("parseSelectSubcubeClauseName", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 611, 3);
            try {
                nameObjectIdentifier = parseNameObjectIdentifier();
            } finally {
                popCallStack();
            }
            // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:612:3
            return new SelectSubcubeClauseNameR(nameObjectIdentifier);
        } catch (ParseException e) {
            parseException466 = e;
            throw e;
        } finally {
            restoreCallStack(callStackSize467);
            if (thisProduction != null) {
                if (parseException466 == null) {
                    closeNodeScope(thisProduction, nodeArity() > 1);
                } else {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction = prevProduction;
        }
    }

    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:618:1
    final public SelectSubcubeClauseStatement parseSelectSubcubeClauseStatement() {
        if (cancelled) throw new CancellationException();
        String prevProduction = currentlyParsedProduction;
        this.currentlyParsedProduction = "parseSelectSubcubeClauseStatement";
        ASTparseSelectSubcubeClauseStatement thisProduction = null;
        if (buildTree) {
            thisProduction = new ASTparseSelectSubcubeClauseStatement();
            openNodeScope(thisProduction);
        }
        SelectQueryClause selectQueryClause = null;
        SelectSubcubeClause selectSubcubeClause = null;
        Optional<SelectSlicerAxisClause> selectSlicerAxisClause = Optional.empty();
        ParseException parseException478 = null;
        int callStackSize479 = parsingStack.size();
        try {
            // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:625:5
            consumeToken(LPAREN);
            // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:625:16
            consumeToken(SELECT);
            // Code for ZeroOrOne specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:626:5
            // Code for ExpansionChoice specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:627:7
            if (nextTokenType() == ASTERISK) {
                // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:627:7
                pushOntoCallStack("parseSelectSubcubeClauseStatement", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 627, 7);
                try {
                    selectQueryClause = parseSelectQueryAsteriskClause();
                } finally {
                    popCallStack();
                }
            } else if (first_set$Grammer_ccc$629$7.contains(nextTokenType())) {
                // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:629:7
                pushOntoCallStack("parseSelectSubcubeClauseStatement", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 629, 7);
                try {
                    selectQueryClause = parseSelectQueryAxesClause();
                } finally {
                    popCallStack();
                }
            } else {
                // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:630:7
                selectQueryClause = new SelectQueryEmptyClauseR();
            }
            // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:634:5
            consumeToken(FROM);
            // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:634:14
            pushOntoCallStack("parseSelectSubcubeClauseStatement", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 634, 14);
            try {
                selectSubcubeClause = parseSelectSubcubeClause();
            } finally {
                popCallStack();
            }
            // Code for ZeroOrOne specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:635:5
            if (nextTokenType() == WHERE) {
                // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:636:7
                pushOntoCallStack("parseSelectSubcubeClauseStatement", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 636, 7);
                try {
                    selectSlicerAxisClause = parseSelectSlicerAxisClause();
                } finally {
                    popCallStack();
                }
            }
            // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:638:5
            consumeToken(RPAREN);
            // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:640:3
            return new SelectSubcubeClauseStatementR(selectQueryClause, selectSubcubeClause, selectSlicerAxisClause);
        } catch (ParseException e) {
            parseException478 = e;
            throw e;
        } finally {
            restoreCallStack(callStackSize479);
            if (thisProduction != null) {
                if (parseException478 == null) {
                    closeNodeScope(thisProduction, nodeArity() > 1);
                } else {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction = prevProduction;
        }
    }

    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:646:1
    final public SelectQueryAsteriskClause parseSelectQueryAsteriskClause() {
        if (cancelled) throw new CancellationException();
        String prevProduction = currentlyParsedProduction;
        this.currentlyParsedProduction = "parseSelectQueryAsteriskClause";
        ASTparseSelectQueryAsteriskClause thisProduction = null;
        if (buildTree) {
            thisProduction = new ASTparseSelectQueryAsteriskClause();
            openNodeScope(thisProduction);
        }
        ParseException parseException555 = null;
        int callStackSize556 = parsingStack.size();
        try {
            // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:647:3
            consumeToken(ASTERISK);
            // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:648:3
            return new SelectQueryAsteriskClauseR();
        } catch (ParseException e) {
            parseException555 = e;
            throw e;
        } finally {
            restoreCallStack(callStackSize556);
            if (thisProduction != null) {
                if (parseException555 == null) {
                    closeNodeScope(thisProduction, nodeArity() > 1);
                } else {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction = prevProduction;
        }
    }

    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:654:1
    final public SelectQueryAxesClause parseSelectQueryAxesClause() {
        if (cancelled) throw new CancellationException();
        String prevProduction = currentlyParsedProduction;
        this.currentlyParsedProduction = "parseSelectQueryAxesClause";
        ASTparseSelectQueryAxesClause thisProduction = null;
        if (buildTree) {
            thisProduction = new ASTparseSelectQueryAxesClause();
            openNodeScope(thisProduction);
        }
        List<SelectQueryAxisClause> selectQueryAxisClauses = new LinkedList<SelectQueryAxisClause>();
        SelectQueryAxisClause selectQueryAxisClause;
        ParseException parseException567 = null;
        int callStackSize568 = parsingStack.size();
        try {
            // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:659:3
            pushOntoCallStack("parseSelectQueryAxesClause", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 659, 3);
            try {
                selectQueryAxisClause = parseSelectQueryAxisClause();
            } finally {
                popCallStack();
            }
            // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:660:3
            selectQueryAxisClauses.add(selectQueryAxisClause);
            // Code for ZeroOrMore specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:663:3
            while (true) {
                if (!(nextTokenType() == COMMA)) break;
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:664:5
                consumeToken(COMMA);
                // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:664:15
                pushOntoCallStack("parseSelectQueryAxesClause", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 664, 15);
                try {
                    selectQueryAxisClause = parseSelectQueryAxisClause();
                } finally {
                    popCallStack();
                }
                // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:665:5
                selectQueryAxisClauses.add(selectQueryAxisClause);
            }
            // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:669:3
            return new SelectQueryAxesClauseR(selectQueryAxisClauses);
        } catch (ParseException e) {
            parseException567 = e;
            throw e;
        } finally {
            restoreCallStack(callStackSize568);
            if (thisProduction != null) {
                if (parseException567 == null) {
                    closeNodeScope(thisProduction, nodeArity() > 1);
                } else {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction = prevProduction;
        }
    }

    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:675:1
    final public Optional<SelectSlicerAxisClause> parseSelectSlicerAxisClause() {
        if (cancelled) throw new CancellationException();
        String prevProduction = currentlyParsedProduction;
        this.currentlyParsedProduction = "parseSelectSlicerAxisClause";
        ASTparseSelectSlicerAxisClause thisProduction = null;
        if (buildTree) {
            thisProduction = new ASTparseSelectSlicerAxisClause();
            openNodeScope(thisProduction);
        }
        Expression expression = null;
        ParseException parseException603 = null;
        int callStackSize604 = parsingStack.size();
        try {
            // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:679:3
            consumeToken(WHERE);
            // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:679:13
            pushOntoCallStack("parseSelectSlicerAxisClause", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 679, 13);
            try {
                expression = parseExpression();
            } finally {
                popCallStack();
            }
            // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:680:3
            if (expression == null) {
                return Optional.empty();
            }
            return Optional.of(new SelectSlicerAxisClauseR(expression));
        } catch (ParseException e) {
            parseException603 = e;
            throw e;
        } finally {
            restoreCallStack(callStackSize604);
            if (thisProduction != null) {
                if (parseException603 == null) {
                    closeNodeScope(thisProduction, nodeArity() > 1);
                } else {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction = prevProduction;
        }
    }

    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:690:1
    final public SelectCellPropertyListClause parseSelectCellPropertyListClause() {
        if (cancelled) throw new CancellationException();
        String prevProduction = currentlyParsedProduction;
        this.currentlyParsedProduction = "parseSelectCellPropertyListClause";
        ASTparseSelectCellPropertyListClause thisProduction = null;
        if (buildTree) {
            thisProduction = new ASTparseSelectCellPropertyListClause();
            openNodeScope(thisProduction);
        }
        List<String> cellProperties = new LinkedList<String>();
        String property = null;
        boolean cell = false;
        ParseException parseException619 = null;
        int callStackSize620 = parsingStack.size();
        try {
            // Code for ZeroOrOne specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:696:3
            if (nextTokenType() == CELL) {
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:696:4
                consumeToken(CELL);
                // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:697:6
                cell = true;
            }
            // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:701:4
            consumeToken(PROPERTIES);
            // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:701:19
            consumeToken(ID);
            // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:702:5
            cellProperties.add(getToken(0).getImage());
            // Code for ZeroOrMore specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:705:3
            while (true) {
                if (!(nextTokenType() == COMMA)) break;
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:706:5
                consumeToken(COMMA);
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:706:15
                consumeToken(ID);
                // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:707:5
                cellProperties.add(getToken(0).getImage());
            }
            // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:711:3
            return new SelectCellPropertyListClauseR(cellProperties, cell);
        } catch (ParseException e) {
            parseException619 = e;
            throw e;
        } finally {
            restoreCallStack(callStackSize620);
            if (thisProduction != null) {
                if (parseException619 == null) {
                    closeNodeScope(thisProduction, nodeArity() > 1);
                } else {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction = prevProduction;
        }
    }

    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:717:1
    final public
    // https://learn.microsoft.com/en-us/sql/mdx/mdx-data-definition-create-member?view=sql-server-ver16
    CreateMemberBodyClause parseCreateMemberBodyClause() {
        if (cancelled) throw new CancellationException();
        String prevProduction = currentlyParsedProduction;
        this.currentlyParsedProduction = "parseCreateMemberBodyClause";
        ASTparseCreateMemberBodyClause thisProduction = null;
        if (buildTree) {
            thisProduction = new ASTparseCreateMemberBodyClause();
            openNodeScope(thisProduction);
        }
        CompoundId compoundId = null;
        Expression expression = null;
        List<MemberPropertyDefinition> memberPropertyDefinitions = new LinkedList<MemberPropertyDefinition>();
        MemberPropertyDefinition memberPropertyDefinition = null;
        ParseException parseException675 = null;
        int callStackSize676 = parsingStack.size();
        try {
            // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:726:3
            pushOntoCallStack("parseCreateMemberBodyClause", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 726, 3);
            try {
                //  <CURRENTCUBE>
                //  |
                compoundId = parseCompoundId();
            } finally {
                popCallStack();
            }
            // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:726:32
            consumeToken(AS);
            // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:726:39
            pushOntoCallStack("parseCreateMemberBodyClause", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 726, 39);
            try {
                expression = parseExpression();
            } finally {
                popCallStack();
            }
            // Code for ZeroOrMore specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:728:3
            while (true) {
                if (!(nextTokenType() == COMMA)) break;
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:729:5
                consumeToken(COMMA);
                // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:729:15
                pushOntoCallStack("parseCreateMemberBodyClause", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 729, 15);
                try {
                    memberPropertyDefinition = parseMemberPropertyDefinition();
                } finally {
                    popCallStack();
                }
                // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:730:5
                memberPropertyDefinitions.add(memberPropertyDefinition);
            }
            // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:735:3
            return new CreateMemberBodyClauseR(compoundId, expression, memberPropertyDefinitions);
        } catch (ParseException e) {
            parseException675 = e;
            throw e;
        } finally {
            restoreCallStack(callStackSize676);
            if (thisProduction != null) {
                if (parseException675 == null) {
                    closeNodeScope(thisProduction, nodeArity() > 1);
                } else {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction = prevProduction;
        }
    }

    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:741:1
    final public MemberPropertyDefinition parseMemberPropertyDefinition() {
        if (cancelled) throw new CancellationException();
        String prevProduction = currentlyParsedProduction;
        this.currentlyParsedProduction = "parseMemberPropertyDefinition";
        ASTparseMemberPropertyDefinition thisProduction = null;
        if (buildTree) {
            thisProduction = new ASTparseMemberPropertyDefinition();
            openNodeScope(thisProduction);
        }
        ObjectIdentifier objectIdentifier;
        Expression expression;
        ParseException parseException715 = null;
        int callStackSize716 = parsingStack.size();
        try {
            // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:746:3
            pushOntoCallStack("parseMemberPropertyDefinition", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 746, 3);
            try {
                objectIdentifier = parseIdentifier();
            } finally {
                popCallStack();
            }
            // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:746:38
            consumeToken(EQ);
            // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:746:45
            pushOntoCallStack("parseMemberPropertyDefinition", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 746, 45);
            try {
                expression = parseExpression();
            } finally {
                popCallStack();
            }
            // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:747:3
            return new MemberPropertyDefinitionR(objectIdentifier, expression);
        } catch (ParseException e) {
            parseException715 = e;
            throw e;
        } finally {
            restoreCallStack(callStackSize716);
            if (thisProduction != null) {
                if (parseException715 == null) {
                    closeNodeScope(thisProduction, nodeArity() > 1);
                } else {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction = prevProduction;
        }
    }

    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:753:1
    final public FormulaExpression parseFormulaExpression() {
        if (cancelled) throw new CancellationException();
        String prevProduction = currentlyParsedProduction;
        this.currentlyParsedProduction = "parseFormulaExpression";
        ASTparseFormulaExpression thisProduction = null;
        if (buildTree) {
            thisProduction = new ASTparseFormulaExpression();
            openNodeScope(thisProduction);
        }
        ParseException parseException735 = null;
        int callStackSize736 = parsingStack.size();
        try {
            // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:754:3
            pushOntoCallStack("parseFormulaExpression", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 754, 3);
            try {
                parseIdentifier();
            } finally {
                popCallStack();
            }
            // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:754:19
            consumeToken(EQ);
            // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:754:26
            pushOntoCallStack("parseFormulaExpression", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 754, 26);
            try {
                parseIdentifier();
            } finally {
                popCallStack();
            }
            // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:755:3
            return new FormulaExpressionR();
        } catch (ParseException e) {
            parseException735 = e;
            throw e;
        } finally {
            restoreCallStack(callStackSize736);
            if (thisProduction != null) {
                if (parseException735 == null) {
                    closeNodeScope(thisProduction, nodeArity() > 1);
                } else {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction = prevProduction;
        }
    }

    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:761:1
    final public Expression parseExpression() {
        if (cancelled) throw new CancellationException();
        String prevProduction = currentlyParsedProduction;
        this.currentlyParsedProduction = "parseExpression";
        ASTparseExpression thisProduction = null;
        if (buildTree) {
            thisProduction = new ASTparseExpression();
            openNodeScope(thisProduction);
        }
        Expression expression;
        ObjectIdentifier objectIdentifier;
        ParseException parseException755 = null;
        int callStackSize756 = parsingStack.size();
        try {
            // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:766:3
            pushOntoCallStack("parseExpression", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 766, 3);
            try {
                expression = parseUnaliasedExpression();
            } finally {
                popCallStack();
            }
            // Code for ZeroOrMore specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:767:3
            while (true) {
                if (!(nextTokenType() == AS)) break;
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:768:5
                consumeToken(AS);
                // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:768:12
                pushOntoCallStack("parseExpression", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 768, 12);
                try {
                    objectIdentifier = parseIdentifier();
                } finally {
                    popCallStack();
                }
                // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:769:5
                CompoundId compundId = new CompoundIdR(List.of(objectIdentifier));
                expression = new CallExpressionR("AS", CallExpression.Type.Term_Infix, List.of(expression, compundId));
            }
            // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:777:3
            return expression;
        } catch (ParseException e) {
            parseException755 = e;
            throw e;
        } finally {
            restoreCallStack(callStackSize756);
            if (thisProduction != null) {
                if (parseException755 == null) {
                    closeNodeScope(thisProduction, nodeArity() > 1);
                } else {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction = prevProduction;
        }
    }

    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:783:1
    final public Expression parseExpressionOrEmpty() {
        if (cancelled) throw new CancellationException();
        String prevProduction = currentlyParsedProduction;
        this.currentlyParsedProduction = "parseExpressionOrEmpty";
        // Code for ExpansionChoice specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:787:3
        ASTparseExpressionOrEmpty thisProduction = null;
        if (buildTree) {
            thisProduction = new ASTparseExpressionOrEmpty();
            openNodeScope(thisProduction);
        }
        Expression expression;
        ParseException parseException787 = null;
        int callStackSize788 = parsingStack.size();
        try {
            if (first_set$Grammer_ccc$787$3.contains(nextTokenType())) {
                // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:787:3
                pushOntoCallStack("parseExpressionOrEmpty", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 787, 3);
                try {
                    expression = parseExpression();
                } finally {
                    popCallStack();
                }
                // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:788:3
                return expression;
            } else {
                // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:792:3
                return new CallExpressionR("", CallExpression.Type.Empty, List.of());
            }
        } catch (ParseException e) {
            parseException787 = e;
            throw e;
        } finally {
            restoreCallStack(callStackSize788);
            if (thisProduction != null) {
                if (parseException787 == null) {
                    closeNodeScope(thisProduction, nodeArity() > 1);
                } else {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction = prevProduction;
        }
    }

    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:801:1
    final public
    // Comma-separated list of expressions, some of which may be empty. Used
    // for functions.
    List<Expression> expOrEmptyList() {
        if (cancelled) throw new CancellationException();
        String prevProduction = currentlyParsedProduction;
        this.currentlyParsedProduction = "expOrEmptyList";
        ASTexpOrEmptyList thisProduction = null;
        if (buildTree) {
            thisProduction = new ASTexpOrEmptyList();
            openNodeScope(thisProduction);
        }
        Expression expression;
        List<Expression> list = new LinkedList<Expression>();
        ParseException parseException811 = null;
        int callStackSize812 = parsingStack.size();
        try {
            // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:806:3
            pushOntoCallStack("expOrEmptyList", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 806, 3);
            try {
                expression = parseExpressionOrEmpty();
            } finally {
                popCallStack();
            }
            // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:807:3
            list.add(expression);
            // Code for ZeroOrMore specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:810:3
            while (true) {
                if (!(nextTokenType() == COMMA)) break;
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:811:5
                consumeToken(COMMA);
                // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:812:5
                pushOntoCallStack("expOrEmptyList", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 812, 5);
                try {
                    expression = parseExpressionOrEmpty();
                } finally {
                    popCallStack();
                }
                // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:813:5
                list.add(expression);
            }
            // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:817:3
            return list;
        } catch (ParseException e) {
            parseException811 = e;
            throw e;
        } finally {
            restoreCallStack(callStackSize812);
            if (thisProduction != null) {
                if (parseException811 == null) {
                    closeNodeScope(thisProduction, nodeArity() > 1);
                } else {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction = prevProduction;
        }
    }

    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:824:1
    final public
    // List of expressions, none of which may be empty.
    List<Expression> expList() {
        if (cancelled) throw new CancellationException();
        String prevProduction = currentlyParsedProduction;
        this.currentlyParsedProduction = "expList";
        ASTexpList thisProduction = null;
        if (buildTree) {
            thisProduction = new ASTexpList();
            openNodeScope(thisProduction);
        }
        Expression expression;
        List<Expression> list = new LinkedList<Expression>();
        ParseException parseException847 = null;
        int callStackSize848 = parsingStack.size();
        try {
            // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:829:3
            pushOntoCallStack("expList", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 829, 3);
            try {
                expression = parseExpression();
            } finally {
                popCallStack();
            }
            // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:830:3
            list.add(expression);
            // Code for ZeroOrMore specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:833:3
            while (true) {
                if (!(nextTokenType() == COMMA)) break;
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:834:5
                consumeToken(COMMA);
                // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:835:5
                pushOntoCallStack("expList", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 835, 5);
                try {
                    expression = parseExpression();
                } finally {
                    popCallStack();
                }
                // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:836:5
                list.add(expression);
            }
            // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:840:3
            return list;
        } catch (ParseException e) {
            parseException847 = e;
            throw e;
        } finally {
            restoreCallStack(callStackSize848);
            if (thisProduction != null) {
                if (parseException847 == null) {
                    closeNodeScope(thisProduction, nodeArity() > 1);
                } else {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction = prevProduction;
        }
    }

    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:846:1
    final public Expression parseExpressionEof() {
        if (cancelled) throw new CancellationException();
        String prevProduction = currentlyParsedProduction;
        this.currentlyParsedProduction = "parseExpressionEof";
        ASTparseExpressionEof thisProduction = null;
        if (buildTree) {
            thisProduction = new ASTparseExpressionEof();
            openNodeScope(thisProduction);
        }
        Expression expression;
        ParseException parseException883 = null;
        int callStackSize884 = parsingStack.size();
        try {
            // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:850:3
            pushOntoCallStack("parseExpressionEof", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 850, 3);
            try {
                expression = parseExpression();
            } finally {
                popCallStack();
            }
            // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:850:32
            consumeToken(EOF);
            // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:851:3
            return expression;
        } catch (ParseException e) {
            parseException883 = e;
            throw e;
        } finally {
            restoreCallStack(callStackSize884);
            if (thisProduction != null) {
                if (parseException883 == null) {
                    closeNodeScope(thisProduction, nodeArity() > 1);
                } else {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction = prevProduction;
        }
    }

    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:857:1
    final public ObjectIdentifier parseIdentifier() {
        if (cancelled) throw new CancellationException();
        String prevProduction = currentlyParsedProduction;
        this.currentlyParsedProduction = "parseIdentifier";
        ASTparseIdentifier thisProduction = null;
        if (buildTree) {
            thisProduction = new ASTparseIdentifier();
            openNodeScope(thisProduction);
        }
        ObjectIdentifier objectIdentifier;
        ParseException parseException899 = null;
        int callStackSize900 = parsingStack.size();
        try {
            if (first_set$Grammer_ccc$862$5.contains(nextTokenType())) {
                // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:862:5
                pushOntoCallStack("parseIdentifier", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 862, 5);
                try {
                    objectIdentifier = parseNameObjectIdentifier();
                } finally {
                    popCallStack();
                }
            } else if (nextTokenType() == AMP_QUOTED_ID || nextTokenType == AMP_UNQUOTED_ID) {
                // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:864:5
                pushOntoCallStack("parseIdentifier", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 864, 5);
                try {
                    objectIdentifier = parseKeyIdentifier();
                } finally {
                    popCallStack();
                }
            } else {
                pushOntoCallStack("parseIdentifier", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 862, 5);
                throw new ParseException(lastConsumedToken, first_set$Grammer_ccc$862$5$, parsingStack);
            }
            // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:866:3
            return objectIdentifier;
        } catch (ParseException e) {
            parseException899 = e;
            throw e;
        } finally {
            restoreCallStack(callStackSize900);
            if (thisProduction != null) {
                if (parseException899 == null) {
                    closeNodeScope(thisProduction, nodeArity() > 1);
                } else {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction = prevProduction;
        }
    }

    static private final EnumSet<TokenType> parseNameObjectIdentifier_FIRST_SET = tokenTypeSet(DIMENSION, PROPERTIES, ATSIGN, ID, QUOTED_ID);

    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:872:1
    final public NameObjectIdentifier parseNameObjectIdentifier() {
        if (cancelled) throw new CancellationException();
        String prevProduction = currentlyParsedProduction;
        this.currentlyParsedProduction = "parseNameObjectIdentifier";
        // Code for ExpansionChoice specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:876:3
        ASTparseNameObjectIdentifier thisProduction = null;
        if (buildTree) {
            thisProduction = new ASTparseNameObjectIdentifier();
            openNodeScope(thisProduction);
        }
        String id;
        ParseException parseException928 = null;
        int callStackSize929 = parsingStack.size();
        try {
            if (nextTokenType() == DIMENSION || nextTokenType == PROPERTIES) {
                // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:876:3
                pushOntoCallStack("parseNameObjectIdentifier", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 876, 3);
                try {
                    id = parseKeyword();
                } finally {
                    popCallStack();
                }
                // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:877:3
                // Keywords that are  not Reserved could be used
                return new NameObjectIdentifierR(id, ObjectIdentifier.Quoting.UNQUOTED);
            } else if (nextTokenType() == ID) {
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:881:3
                consumeToken(ID);
                // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:882:3
                return new NameObjectIdentifierR(getToken(0).getImage(), ObjectIdentifier.Quoting.UNQUOTED);
            } else if (nextTokenType() == ATSIGN) {
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:885:3
                consumeToken(ATSIGN);
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:885:14
                consumeToken(ID);
                // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:886:3
                return new NameObjectIdentifierR("@" + getToken(0).getImage(), ObjectIdentifier.Quoting.UNQUOTED);
            } else if (nextTokenType() == QUOTED_ID) {
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:889:3
                consumeToken(QUOTED_ID);
                // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:890:3
                return new NameObjectIdentifierR(MdxParserUtil.stripQuotes(getToken(0).getImage(), "[", "]", "]]"), ObjectIdentifier.Quoting.QUOTED);
            } else {
                pushOntoCallStack("parseNameObjectIdentifier", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 876, 3);
                throw new ParseException(lastConsumedToken, parseNameObjectIdentifier_FIRST_SET, parsingStack);
            }
        } catch (ParseException e) {
            parseException928 = e;
            throw e;
        } finally {
            restoreCallStack(callStackSize929);
            if (thisProduction != null) {
                if (parseException928 == null) {
                    closeNodeScope(thisProduction, nodeArity() > 1);
                } else {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction = prevProduction;
        }
    }

    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:899:1
    final public
    // for example '&foo&[1]&bar' in '[x].&foo&[1]&bar.[y]'
    KeyObjectIdentifier parseKeyIdentifier() {
        if (cancelled) throw new CancellationException();
        String prevProduction = currentlyParsedProduction;
        this.currentlyParsedProduction = "parseKeyIdentifier";
        ASTparseKeyIdentifier thisProduction = null;
        if (buildTree) {
            thisProduction = new ASTparseKeyIdentifier();
            openNodeScope(thisProduction);
        }
        List<NameObjectIdentifier> list = new ArrayList<NameObjectIdentifier>();
        NameObjectIdentifier key;
        ParseException parseException984 = null;
        int callStackSize985 = parsingStack.size();
        try {
            // Code for OneOrMore specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:904:3
            while (true) {
                // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:905:5
                pushOntoCallStack("parseKeyIdentifier", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 905, 5);
                try {
                    key = parseAmpId();
                } finally {
                    popCallStack();
                }
                // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:906:5
                list.add(key);
                if (!(nextTokenType() == AMP_QUOTED_ID || nextTokenType == AMP_UNQUOTED_ID)) break;
            }
            // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:910:3
            return new KeyObjectIdentifierR(list);
        } catch (ParseException e) {
            parseException984 = e;
            throw e;
        } finally {
            restoreCallStack(callStackSize985);
            if (thisProduction != null) {
                if (parseException984 == null) {
                    closeNodeScope(thisProduction, nodeArity() > 1);
                } else {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction = prevProduction;
        }
    }

    static private final EnumSet<TokenType> parseAmpId_FIRST_SET = tokenTypeSet(AMP_QUOTED_ID, AMP_UNQUOTED_ID);

    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:916:1
    final public NameObjectIdentifier parseAmpId() {
        if (cancelled) throw new CancellationException();
        String prevProduction = currentlyParsedProduction;
        this.currentlyParsedProduction = "parseAmpId";
        // Code for ExpansionChoice specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:917:3
        ASTparseAmpId thisProduction = null;
        if (buildTree) {
            thisProduction = new ASTparseAmpId();
            openNodeScope(thisProduction);
        }
        ParseException parseException1008 = null;
        int callStackSize1009 = parsingStack.size();
        try {
            if (nextTokenType() == AMP_QUOTED_ID) {
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:917:3
                consumeToken(AMP_QUOTED_ID);
                // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:918:3
                return new NameObjectIdentifierR(MdxParserUtil.stripQuotes(getToken(0).getImage(), "&[", "]", "]]"), ObjectIdentifier.Quoting.QUOTED);
            } else if (nextTokenType() == AMP_UNQUOTED_ID) {
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:924:3
                consumeToken(AMP_UNQUOTED_ID);
                // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:925:3
                return new NameObjectIdentifierR(getToken(0).getImage().substring(1), ObjectIdentifier.Quoting.UNQUOTED);
            } else {
                pushOntoCallStack("parseAmpId", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 917, 3);
                throw new ParseException(lastConsumedToken, parseAmpId_FIRST_SET, parsingStack);
            }
        } catch (ParseException e) {
            parseException1008 = e;
            throw e;
        } finally {
            restoreCallStack(callStackSize1009);
            if (thisProduction != null) {
                if (parseException1008 == null) {
                    closeNodeScope(thisProduction, nodeArity() > 1);
                } else {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction = prevProduction;
        }
    }

    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:934:1
    final public
    // a keyword that is not a RESERVED_WORD could be used as identifier
    String parseKeyword() {
        if (cancelled) throw new CancellationException();
        String prevProduction = currentlyParsedProduction;
        this.currentlyParsedProduction = "parseKeyword";
        ASTparseKeyword thisProduction = null;
        if (buildTree) {
            thisProduction = new ASTparseKeyword();
            openNodeScope(thisProduction);
        }
        ParseException parseException1036 = null;
        int callStackSize1037 = parsingStack.size();
        try {
            if (nextTokenType() == DIMENSION) {
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:936:5
                consumeToken(DIMENSION);
            } else if (nextTokenType() == PROPERTIES) {
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:937:5
                consumeToken(PROPERTIES);
            } else {
                pushOntoCallStack("parseKeyword", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 936, 5);
                throw new ParseException(lastConsumedToken, first_set$Grammer_ccc$936$5, parsingStack);
            }
            // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:939:3
            return getToken(0).getImage();
        } catch (ParseException e) {
            parseException1036 = e;
            throw e;
        } finally {
            restoreCallStack(callStackSize1037);
            if (thisProduction != null) {
                if (parseException1036 == null) {
                    closeNodeScope(thisProduction, nodeArity() > 1);
                } else {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction = prevProduction;
        }
    }

    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:945:1
    final public CompoundId parseCompoundId() {
        if (cancelled) throw new CancellationException();
        String prevProduction = currentlyParsedProduction;
        this.currentlyParsedProduction = "parseCompoundId";
        ASTparseCompoundId thisProduction = null;
        if (buildTree) {
            thisProduction = new ASTparseCompoundId();
            openNodeScope(thisProduction);
        }
        CompoundId compoundId;
        List<ObjectIdentifier> list = new ArrayList<ObjectIdentifier>();
        ObjectIdentifier s;
        ParseException parseException1065 = null;
        int callStackSize1066 = parsingStack.size();
        try {
            // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:951:3
            pushOntoCallStack("parseCompoundId", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 951, 3);
            try {
                s = parseIdentifier();
            } finally {
                popCallStack();
            }
            // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:952:3
            list.add(s);
            // Code for ZeroOrMore specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:955:3
            while (true) {
                if (!(scan$Grammer_ccc$956$5())) break;
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:957:5
                consumeToken(DOT);
                // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:957:13
                pushOntoCallStack("parseCompoundId", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 957, 13);
                try {
                    s = parseIdentifier();
                } finally {
                    popCallStack();
                }
                // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:958:5
                list.add(s);
            }
            // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:962:3
            return new CompoundIdR(list);
        } catch (ParseException e) {
            parseException1065 = e;
            throw e;
        } finally {
            restoreCallStack(callStackSize1066);
            if (thisProduction != null) {
                if (parseException1065 == null) {
                    closeNodeScope(thisProduction, nodeArity() > 1);
                } else {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction = prevProduction;
        }
    }

    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:970:1
    final public
    // ----------------------------------------------------------------------------
    // Expressions
    Expression parseUnaliasedExpression() {
        if (cancelled) throw new CancellationException();
        String prevProduction = currentlyParsedProduction;
        this.currentlyParsedProduction = "parseUnaliasedExpression";
        ASTparseUnaliasedExpression thisProduction = null;
        if (buildTree) {
            thisProduction = new ASTparseUnaliasedExpression();
            openNodeScope(thisProduction);
        }
        Expression x, y;
        ParseException parseException1101 = null;
        int callStackSize1102 = parsingStack.size();
        try {
            // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:974:3
            pushOntoCallStack("parseUnaliasedExpression", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 974, 3);
            try {
                x = parseTerm5();
            } finally {
                popCallStack();
            }
            // Code for ZeroOrMore specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:975:3
            while (true) {
                // Code for ExpansionChoice specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:976:5
                if (nextTokenType() == OR) {
                    // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:976:5
                    consumeToken(OR);
                    // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:976:12
                    pushOntoCallStack("parseUnaliasedExpression", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 976, 12);
                    try {
                        y = parseTerm5();
                    } finally {
                        popCallStack();
                    }
                    // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:977:5
                    x = new CallExpressionR("OR", CallExpression.Type.Term_Infix, List.of(x, y));
                } else if (nextTokenType() == XOR) {
                    // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:983:5
                    consumeToken(XOR);
                    // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:983:13
                    pushOntoCallStack("parseUnaliasedExpression", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 983, 13);
                    try {
                        y = parseTerm5();
                    } finally {
                        popCallStack();
                    }
                    // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:984:5
                    x = new CallExpressionR("XOR", CallExpression.Type.Term_Infix, List.of(x, y));
                } else if (nextTokenType() == COLON) {
                    // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:992:5
                    consumeToken(COLON);
                    // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:992:15
                    pushOntoCallStack("parseUnaliasedExpression", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 992, 15);
                    try {
                        y = parseTerm5();
                    } finally {
                        popCallStack();
                    }
                    // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:993:5
                    x = new CallExpressionR(":", CallExpression.Type.Term_Infix, List.of(x, y));
                } else {
                    break;
                }
            }
            // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1000:3
            return x;
        } catch (ParseException e) {
            parseException1101 = e;
            throw e;
        } finally {
            restoreCallStack(callStackSize1102);
            if (thisProduction != null) {
                if (parseException1101 == null) {
                    closeNodeScope(thisProduction, nodeArity() > 1);
                } else {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction = prevProduction;
        }
    }

    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1006:1
    final public Expression parseTerm5() {
        if (cancelled) throw new CancellationException();
        String prevProduction = currentlyParsedProduction;
        this.currentlyParsedProduction = "parseTerm5";
        ASTparseTerm5 thisProduction = null;
        if (buildTree) {
            thisProduction = new ASTparseTerm5();
            openNodeScope(thisProduction);
        }
        Expression x, y;
        ParseException parseException1169 = null;
        int callStackSize1170 = parsingStack.size();
        try {
            // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1010:3
            pushOntoCallStack("parseTerm5", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1010, 3);
            try {
                x = parseTerm4();
            } finally {
                popCallStack();
            }
            // Code for ZeroOrMore specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1011:3
            while (true) {
                if (!(nextTokenType() == AND)) break;
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1012:5
                consumeToken(AND);
                // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1012:13
                pushOntoCallStack("parseTerm5", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1012, 13);
                try {
                    y = parseTerm4();
                } finally {
                    popCallStack();
                }
                // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1013:5
                x = new CallExpressionR("AND", CallExpression.Type.Term_Infix, List.of(x, y));
            }
            // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1020:3
            return x;
        } catch (ParseException e) {
            parseException1169 = e;
            throw e;
        } finally {
            restoreCallStack(callStackSize1170);
            if (thisProduction != null) {
                if (parseException1169 == null) {
                    closeNodeScope(thisProduction, nodeArity() > 1);
                } else {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction = prevProduction;
        }
    }

    static private final EnumSet<TokenType> parseTerm4_FIRST_SET = parseTerm4_FIRST_SET_init();

    static private EnumSet<TokenType> parseTerm4_FIRST_SET_init() {
        return tokenTypeSet(CASE, CAST, DIMENSION, NOT, NULL, PROPERTIES, EXISTING, LPAREN, LBRACE, MINUS, PLUS, ATSIGN, ID, QUOTED_ID, UNSIGNED_INTEGER_LITERAL, APPROX_NUMERIC_LITERAL, DECIMAL_NUMERIC_LITERAL, SINGLE_QUOTED_STRING, DOUBLE_QUOTED_STRING);
    }

    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1026:1
    final public Expression parseTerm4() {
        if (cancelled) throw new CancellationException();
        String prevProduction = currentlyParsedProduction;
        this.currentlyParsedProduction = "parseTerm4";
        // Code for ExpansionChoice specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1030:3
        ASTparseTerm4 thisProduction = null;
        if (buildTree) {
            thisProduction = new ASTparseTerm4();
            openNodeScope(thisProduction);
        }
        Expression x;
        ParseException parseException1201 = null;
        int callStackSize1202 = parsingStack.size();
        try {
            if (first_set$Grammer_ccc$1030$3.contains(nextTokenType())) {
                // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1030:3
                pushOntoCallStack("parseTerm4", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1030, 3);
                try {
                    x = parseTerm3();
                } finally {
                    popCallStack();
                }
                // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1031:3
                return x;
            } else if (nextTokenType() == NOT) {
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1034:3
                consumeToken(NOT);
                // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1034:11
                pushOntoCallStack("parseTerm4", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1034, 11);
                try {
                    x = parseTerm4();
                } finally {
                    popCallStack();
                }
                // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1035:3
                return new CallExpressionR("NOT", CallExpression.Type.Term_Prefix, List.of(x));
            } else {
                pushOntoCallStack("parseTerm4", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1030, 3);
                throw new ParseException(lastConsumedToken, parseTerm4_FIRST_SET, parsingStack);
            }
        } catch (ParseException e) {
            parseException1201 = e;
            throw e;
        } finally {
            restoreCallStack(callStackSize1202);
            if (thisProduction != null) {
                if (parseException1201 == null) {
                    closeNodeScope(thisProduction, nodeArity() > 1);
                } else {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction = prevProduction;
        }
    }

    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1044:1
    final public Expression parseTerm3() {
        if (cancelled) throw new CancellationException();
        String prevProduction = currentlyParsedProduction;
        this.currentlyParsedProduction = "parseTerm3";
        ASTparseTerm3 thisProduction = null;
        if (buildTree) {
            thisProduction = new ASTparseTerm3();
            openNodeScope(thisProduction);
        }
        Expression x, y;
        Token op;
        ParseException parseException1233 = null;
        int callStackSize1234 = parsingStack.size();
        try {
            // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1049:3
            pushOntoCallStack("parseTerm3", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1049, 3);
            try {
                x = parseTerm2();
            } finally {
                popCallStack();
            }
            // Code for ZeroOrMore specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1050:3
            while (true) {
                // Code for ExpansionChoice specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1052:5
                if (first_set$Grammer_ccc$1052$5.contains(nextTokenType())) {
                    if (nextTokenType() == EQ) {
                        // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1053:7
                        consumeToken(EQ);
                        // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1054:7
                        op = getToken(0);
                    } else if (nextTokenType() == NE) {
                        // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1057:7
                        consumeToken(NE);
                        // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1058:7
                        op = getToken(0);
                    } else if (nextTokenType() == LT) {
                        // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1061:7
                        consumeToken(LT);
                        // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1062:7
                        op = getToken(0);
                    } else if (nextTokenType() == GT) {
                        // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1065:7
                        consumeToken(GT);
                        // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1066:7
                        op = getToken(0);
                    } else if (nextTokenType() == LE) {
                        // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1069:7
                        consumeToken(LE);
                        // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1070:7
                        op = getToken(0);
                    } else if (nextTokenType() == GE) {
                        // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1073:7
                        consumeToken(GE);
                        // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1074:7
                        op = getToken(0);
                    } else {
                        pushOntoCallStack("parseTerm3", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1053, 7);
                        throw new ParseException(lastConsumedToken, first_set$Grammer_ccc$1053$7, parsingStack);
                    }
                    // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1078:5
                    pushOntoCallStack("parseTerm3", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1078, 5);
                    try {
                        y = parseTerm2();
                    } finally {
                        popCallStack();
                    }
                    // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1079:5
                    x = new CallExpressionR(op.getImage(), CallExpression.Type.Term_Infix, List.of(x, y));
                } else if (scan$Grammer_ccc$1088$5()) {
                    // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1089:5
                    consumeToken(IS);
                    // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1089:12
                    consumeToken(NULL);
                    // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1090:5
                    x = new CallExpressionR("IS NULL", CallExpression.Type.Term_Postfix, List.of(x));
                } else if (scan$Grammer_ccc$1098$5()) {
                    // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1099:5
                    consumeToken(IS);
                    // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1099:12
                    pushOntoCallStack("parseTerm3", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1099, 12);
                    try {
                        y = parseTerm2();
                    } finally {
                        popCallStack();
                    }
                    // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1100:5
                    x = new CallExpressionR("IS", CallExpression.Type.Term_Infix, List.of(x, y));
                } else if (nextTokenType() == IS) {
                    // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1106:5
                    consumeToken(IS);
                    // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1106:12
                    consumeToken(EMPTY);
                    // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1107:5
                    x = new CallExpressionR("IS EMPTY", CallExpression.Type.Term_Postfix, List.of(x));
                } else if (nextTokenType() == MATCHES) {
                    // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1111:5
                    consumeToken(MATCHES);
                    // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1111:17
                    pushOntoCallStack("parseTerm3", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1111, 17);
                    try {
                        y = parseTerm2();
                    } finally {
                        popCallStack();
                    }
                    // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1112:5
                    x = new CallExpressionR("MATCHES", CallExpression.Type.Term_Infix, List.of(x, y));
                } else if (scan$Grammer_ccc$1118$5()) {
                    // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1119:5
                    consumeToken(NOT);
                    // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1119:13
                    consumeToken(MATCHES);
                    // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1119:25
                    pushOntoCallStack("parseTerm3", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1119, 25);
                    try {
                        y = parseTerm2();
                    } finally {
                        popCallStack();
                    }
                    // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1120:5
                    x = new CallExpressionR("NOT", CallExpression.Type.Term_Prefix, List.of(new CallExpressionR("MATCHES", CallExpression.Type.Term_Infix, List.of(x, y))));
                } else if (nextTokenType() == IN) {
                    // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1131:5
                    consumeToken(IN);
                    // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1131:12
                    pushOntoCallStack("parseTerm3", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1131, 12);
                    try {
                        y = parseTerm2();
                    } finally {
                        popCallStack();
                    }
                    // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1132:5
                    x = new CallExpressionR("IN", CallExpression.Type.Term_Infix, List.of(x, y));
                } else if (nextTokenType() == NOT) {
                    // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1138:5
                    consumeToken(NOT);
                    // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1138:13
                    consumeToken(IN);
                    // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1138:20
                    pushOntoCallStack("parseTerm3", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1138, 20);
                    try {
                        y = parseTerm2();
                    } finally {
                        popCallStack();
                    }
                    // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1139:5
                    x = new CallExpressionR("NOT", CallExpression.Type.Term_Prefix, List.of(new CallExpressionR("IN", CallExpression.Type.Term_Infix, List.of(x, y))));
                } else {
                    break;
                }
            }
            // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1151:3
            return x;
        } catch (ParseException e) {
            parseException1233 = e;
            throw e;
        } finally {
            restoreCallStack(callStackSize1234);
            if (thisProduction != null) {
                if (parseException1233 == null) {
                    closeNodeScope(thisProduction, nodeArity() > 1);
                } else {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction = prevProduction;
        }
    }

    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1157:1
    final public Expression parseTerm2() {
        if (cancelled) throw new CancellationException();
        String prevProduction = currentlyParsedProduction;
        this.currentlyParsedProduction = "parseTerm2";
        ASTparseTerm2 thisProduction = null;
        if (buildTree) {
            thisProduction = new ASTparseTerm2();
            openNodeScope(thisProduction);
        }
        Expression x, y;
        ParseException parseException1462 = null;
        int callStackSize1463 = parsingStack.size();
        try {
            // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1161:3
            pushOntoCallStack("parseTerm2", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1161, 3);
            try {
                x = parseTerm();
            } finally {
                popCallStack();
            }
            // Code for ZeroOrMore specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1162:3
            while (true) {
                // Code for ExpansionChoice specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1163:5
                if (nextTokenType() == PLUS) {
                    // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1163:5
                    consumeToken(PLUS);
                    // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1163:14
                    pushOntoCallStack("parseTerm2", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1163, 14);
                    try {
                        y = parseTerm();
                    } finally {
                        popCallStack();
                    }
                    // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1164:5
                    x = new CallExpressionR("+", CallExpression.Type.Term_Infix, List.of(x, y));
                } else if (nextTokenType() == MINUS) {
                    // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1170:5
                    consumeToken(MINUS);
                    // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1170:15
                    pushOntoCallStack("parseTerm2", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1170, 15);
                    try {
                        y = parseTerm();
                    } finally {
                        popCallStack();
                    }
                    // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1171:5
                    x = new CallExpressionR("-", CallExpression.Type.Term_Infix, List.of(x, y));
                } else if (nextTokenType() == CONCAT) {
                    // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1177:5
                    consumeToken(CONCAT);
                    // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1177:16
                    pushOntoCallStack("parseTerm2", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1177, 16);
                    try {
                        y = parseTerm();
                    } finally {
                        popCallStack();
                    }
                    // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1178:5
                    x = new CallExpressionR("||", CallExpression.Type.Term_Infix, List.of(x, y));
                } else {
                    break;
                }
            }
            // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1185:3
            return x;
        } catch (ParseException e) {
            parseException1462 = e;
            throw e;
        } finally {
            restoreCallStack(callStackSize1463);
            if (thisProduction != null) {
                if (parseException1462 == null) {
                    closeNodeScope(thisProduction, nodeArity() > 1);
                } else {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction = prevProduction;
        }
    }

    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1191:1
    final public Expression parseTerm() {
        if (cancelled) throw new CancellationException();
        String prevProduction = currentlyParsedProduction;
        this.currentlyParsedProduction = "parseTerm";
        ASTparseTerm thisProduction = null;
        if (buildTree) {
            thisProduction = new ASTparseTerm();
            openNodeScope(thisProduction);
        }
        Expression x, y;
        ParseException parseException1530 = null;
        int callStackSize1531 = parsingStack.size();
        try {
            // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1195:3
            pushOntoCallStack("parseTerm", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1195, 3);
            try {
                x = parseFactor();
            } finally {
                popCallStack();
            }
            // Code for ZeroOrMore specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1196:3
            while (true) {
                // Code for ExpansionChoice specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1197:5
                if (nextTokenType() == ASTERISK) {
                    // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1197:5
                    consumeToken(ASTERISK);
                    // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1197:18
                    pushOntoCallStack("parseTerm", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1197, 18);
                    try {
                        y = parseFactor();
                    } finally {
                        popCallStack();
                    }
                    // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1198:5
                    x = new CallExpressionR("*", CallExpression.Type.Term_Infix, List.of(x, y));
                } else if (nextTokenType() == SOLIDUS) {
                    // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1204:5
                    consumeToken(SOLIDUS);
                    // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1204:17
                    pushOntoCallStack("parseTerm", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1204, 17);
                    try {
                        y = parseFactor();
                    } finally {
                        popCallStack();
                    }
                    // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1205:5
                    x = new CallExpressionR("/", CallExpression.Type.Term_Infix, List.of(x, y));
                } else {
                    break;
                }
            }
            // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1212:3
            return x;
        } catch (ParseException e) {
            parseException1530 = e;
            throw e;
        } finally {
            restoreCallStack(callStackSize1531);
            if (thisProduction != null) {
                if (parseException1530 == null) {
                    closeNodeScope(thisProduction, nodeArity() > 1);
                } else {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction = prevProduction;
        }
    }

    static private final EnumSet<TokenType> parseFactor_FIRST_SET = parseFactor_FIRST_SET_init();

    static private EnumSet<TokenType> parseFactor_FIRST_SET_init() {
        return tokenTypeSet(CASE, CAST, DIMENSION, NULL, PROPERTIES, EXISTING, LPAREN, LBRACE, MINUS, PLUS, ATSIGN, ID, QUOTED_ID, UNSIGNED_INTEGER_LITERAL, APPROX_NUMERIC_LITERAL, DECIMAL_NUMERIC_LITERAL, SINGLE_QUOTED_STRING, DOUBLE_QUOTED_STRING);
    }

    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1218:1
    final public Expression parseFactor() {
        if (cancelled) throw new CancellationException();
        String prevProduction = currentlyParsedProduction;
        this.currentlyParsedProduction = "parseFactor";
        // Code for ExpansionChoice specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1222:3
        ASTparseFactor thisProduction = null;
        if (buildTree) {
            thisProduction = new ASTparseFactor();
            openNodeScope(thisProduction);
        }
        Expression p;
        ParseException parseException1582 = null;
        int callStackSize1583 = parsingStack.size();
        try {
            if (first_set$Grammer_ccc$1222$3.contains(nextTokenType())) {
                // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1222:3
                pushOntoCallStack("parseFactor", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1222, 3);
                try {
                    p = parsePrimary();
                } finally {
                    popCallStack();
                }
                // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1223:3
                return p;
            } else if (nextTokenType() == PLUS) {
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1226:3
                consumeToken(PLUS);
                // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1226:12
                pushOntoCallStack("parseFactor", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1226, 12);
                try {
                    p = parsePrimary();
                } finally {
                    popCallStack();
                }
                // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1227:3
                return p;
            } else if (nextTokenType() == MINUS) {
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1230:3
                consumeToken(MINUS);
                // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1230:13
                pushOntoCallStack("parseFactor", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1230, 13);
                try {
                    p = parsePrimary();
                } finally {
                    popCallStack();
                }
                // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1231:3
                return new CallExpressionR("-", CallExpression.Type.Term_Prefix, List.of(p));
            } else if (nextTokenType() == EXISTING) {
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1237:3
                consumeToken(EXISTING);
                // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1237:16
                pushOntoCallStack("parseFactor", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1237, 16);
                try {
                    p = parsePrimary();
                } finally {
                    popCallStack();
                }
                // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1238:3
                return new CallExpressionR("Existing", CallExpression.Type.Term_Prefix, List.of(p));
            } else {
                pushOntoCallStack("parseFactor", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1222, 3);
                throw new ParseException(lastConsumedToken, parseFactor_FIRST_SET, parsingStack);
            }
        } catch (ParseException e) {
            parseException1582 = e;
            throw e;
        } finally {
            restoreCallStack(callStackSize1583);
            if (thisProduction != null) {
                if (parseException1582 == null) {
                    closeNodeScope(thisProduction, nodeArity() > 1);
                } else {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction = prevProduction;
        }
    }

    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1247:1
    final public Expression parsePrimary() {
        if (cancelled) throw new CancellationException();
        String prevProduction = currentlyParsedProduction;
        this.currentlyParsedProduction = "parsePrimary";
        ASTparsePrimary thisProduction = null;
        if (buildTree) {
            thisProduction = new ASTparsePrimary();
            openNodeScope(thisProduction);
        }
        Expression expression;
        ParseException parseException1646 = null;
        int callStackSize1647 = parsingStack.size();
        try {
            // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1251:3
            pushOntoCallStack("parsePrimary", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1251, 3);
            try {
                expression = parseAtom();
            } finally {
                popCallStack();
            }
            // Code for ZeroOrMore specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1252:3
            while (true) {
                if (!(nextTokenType() == DOT)) break;
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1253:5
                consumeToken(DOT);
                // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1253:13
                pushOntoCallStack("parsePrimary", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1253, 13);
                try {
                    expression = objectIdentifierOrFuncall(expression);
                } finally {
                    popCallStack();
                }
            }
            // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1255:3
            return expression;
        } catch (ParseException e) {
            parseException1646 = e;
            throw e;
        } finally {
            restoreCallStack(callStackSize1647);
            if (thisProduction != null) {
                if (parseException1646 == null) {
                    closeNodeScope(thisProduction, nodeArity() > 1);
                } else {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction = prevProduction;
        }
    }

    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1261:1
    final public Expression objectIdentifierOrFuncall(Expression left) {
        if (cancelled) throw new CancellationException();
        String prevProduction = currentlyParsedProduction;
        this.currentlyParsedProduction = "objectIdentifierOrFuncall";
        ASTobjectIdentifierOrFuncall thisProduction = null;
        if (buildTree) {
            thisProduction = new ASTobjectIdentifierOrFuncall();
            openNodeScope(thisProduction);
        }
        ObjectIdentifier objectIdentifier;
        List<Expression> argList = null;
        ParseException parseException1674 = null;
        int callStackSize1675 = parsingStack.size();
        try {
            // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1266:3
            pushOntoCallStack("objectIdentifierOrFuncall", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1266, 3);
            try {
                objectIdentifier = parseIdentifier();
            } finally {
                popCallStack();
            }
            // Code for ZeroOrOne specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1267:3
            if (nextTokenType() == LPAREN) {
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1268:5
                consumeToken(LPAREN);
                // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1270:7
                pushOntoCallStack("objectIdentifierOrFuncall", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1270, 7);
                try {
                    argList = expOrEmptyList();
                } finally {
                    popCallStack();
                }
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1272:5
                consumeToken(RPAREN);
            }
            // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1274:3
            return MdxParserUtil.createCall(left, objectIdentifier, argList);
        } catch (ParseException e) {
            parseException1674 = e;
            throw e;
        } finally {
            restoreCallStack(callStackSize1675);
            if (thisProduction != null) {
                if (parseException1674 == null) {
                    closeNodeScope(thisProduction, nodeArity() > 1);
                } else {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction = prevProduction;
        }
    }

    static private final EnumSet<TokenType> parseNumericLiteral_FIRST_SET = tokenTypeSet(UNSIGNED_INTEGER_LITERAL, APPROX_NUMERIC_LITERAL, DECIMAL_NUMERIC_LITERAL);

    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1280:1
    final public NumericLiteral parseNumericLiteral() {
        if (cancelled) throw new CancellationException();
        String prevProduction = currentlyParsedProduction;
        this.currentlyParsedProduction = "parseNumericLiteral";
        // Code for ExpansionChoice specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1281:3
        ASTparseNumericLiteral thisProduction = null;
        if (buildTree) {
            thisProduction = new ASTparseNumericLiteral();
            openNodeScope(thisProduction);
        }
        ParseException parseException1711 = null;
        int callStackSize1712 = parsingStack.size();
        try {
            if (nextTokenType() == DECIMAL_NUMERIC_LITERAL) {
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1281:3
                consumeToken(DECIMAL_NUMERIC_LITERAL);
                // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1282:3
                return new NumericLiteralR(new BigDecimal(getToken(0).getImage()));
            } else if (nextTokenType() == UNSIGNED_INTEGER_LITERAL) {
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1285:3
                consumeToken(UNSIGNED_INTEGER_LITERAL);
                // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1286:3
                return new NumericLiteralR(new BigDecimal(getToken(0).getImage()));
            } else if (nextTokenType() == APPROX_NUMERIC_LITERAL) {
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1289:3
                consumeToken(APPROX_NUMERIC_LITERAL);
                // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1290:3
                return new NumericLiteralR(new BigDecimal(getToken(0).getImage()));
            } else {
                pushOntoCallStack("parseNumericLiteral", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1281, 3);
                throw new ParseException(lastConsumedToken, parseNumericLiteral_FIRST_SET, parsingStack);
            }
        } catch (ParseException e) {
            parseException1711 = e;
            throw e;
        } finally {
            restoreCallStack(callStackSize1712);
            if (thisProduction != null) {
                if (parseException1711 == null) {
                    closeNodeScope(thisProduction, nodeArity() > 1);
                } else {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction = prevProduction;
        }
    }

    static private final EnumSet<TokenType> parseAtom_FIRST_SET = parseAtom_FIRST_SET_init();

    static private EnumSet<TokenType> parseAtom_FIRST_SET_init() {
        return tokenTypeSet(CASE, CAST, DIMENSION, NULL, PROPERTIES, LPAREN, LBRACE, ATSIGN, ID, QUOTED_ID, UNSIGNED_INTEGER_LITERAL, APPROX_NUMERIC_LITERAL, DECIMAL_NUMERIC_LITERAL, SINGLE_QUOTED_STRING, DOUBLE_QUOTED_STRING);
    }

    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1296:1
    final public Expression parseAtom() {
        if (cancelled) throw new CancellationException();
        String prevProduction = currentlyParsedProduction;
        this.currentlyParsedProduction = "parseAtom";
        // Code for ExpansionChoice specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1302:3
        ASTparseAtom thisProduction = null;
        if (buildTree) {
            thisProduction = new ASTparseAtom();
            openNodeScope(thisProduction);
        }
        Expression expression;
        NameObjectIdentifier nameObjectIdentifier;
        List<Expression> expressions;
        ParseException parseException1751 = null;
        int callStackSize1752 = parsingStack.size();
        try {
            if (nextTokenType() == SINGLE_QUOTED_STRING) {
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1302:3
                consumeToken(SINGLE_QUOTED_STRING);
                // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1303:3
                return new StringLiteralR(MdxParserUtil.stripQuotes(getToken(0).getImage(), "'", "'", "''"));
            } else if (nextTokenType() == DOUBLE_QUOTED_STRING) {
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1306:3
                consumeToken(DOUBLE_QUOTED_STRING);
                // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1307:3
                return new StringLiteralR(MdxParserUtil.stripQuotes(getToken(0).getImage(), '"' + "", '"' + "", '"' + "" + '"'));
            } else if (nextTokenType() == UNSIGNED_INTEGER_LITERAL || nextTokenType == APPROX_NUMERIC_LITERAL || nextTokenType == DECIMAL_NUMERIC_LITERAL) {
                // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1310:3
                pushOntoCallStack("parseAtom", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1310, 3);
                try {
                    expression = parseNumericLiteral();
                } finally {
                    popCallStack();
                }
                // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1311:3
                return expression;
            } else if (nextTokenType() == NULL) {
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1314:3
                consumeToken(NULL);
                // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1315:3
                return NullLiteralR.SINGLETON;
            } else if (nextTokenType() == CAST) {
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1318:3
                consumeToken(CAST);
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1318:12
                consumeToken(LPAREN);
                // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1318:23
                pushOntoCallStack("parseAtom", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1318, 23);
                try {
                    expression = parseUnaliasedExpression();
                } finally {
                    popCallStack();
                }
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1319:3
                consumeToken(AS);
                // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1319:10
                pushOntoCallStack("parseAtom", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1319, 10);
                try {
                    nameObjectIdentifier = parseNameObjectIdentifier();
                } finally {
                    popCallStack();
                }
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1319:59
                consumeToken(RPAREN);
                // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1320:3
                return new CallExpressionR("CAST", CallExpression.Type.Cast, List.of(expression, new SymbolLiteralR(nameObjectIdentifier.name())));
            } else if (nextTokenType() == LPAREN) {
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1328:3
                consumeToken(LPAREN);
                // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1328:14
                pushOntoCallStack("parseAtom", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1328, 14);
                try {
                    expressions = expList();
                } finally {
                    popCallStack();
                }
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1328:36
                consumeToken(RPAREN);
                // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1329:3
                // Whereas ([Sales],[Time]) and () are tuples, ([Sales]) and (5)
                // are just expressions.
                return new CallExpressionR("()", CallExpression.Type.Parentheses, expressions);
            } else if (nextTokenType() == LBRACE) {
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1337:3
                consumeToken(LBRACE);
                if (scan$Grammer_ccc$1339$5()) {
                    // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1340:5
                    expressions = Collections.emptyList();
                } else if (first_set$Grammer_ccc$1344$5.contains(nextTokenType())) {
                    // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1344:5
                    pushOntoCallStack("parseAtom", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1344, 5);
                    try {
                        expressions = expList();
                    } finally {
                        popCallStack();
                    }
                } else {
                    pushOntoCallStack("parseAtom", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1339, 5);
                    throw new ParseException(lastConsumedToken, first_set$Grammer_ccc$1339$5, parsingStack);
                }
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1346:3
                consumeToken(RBRACE);
                // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1347:3
                return new CallExpressionR("{}", CallExpression.Type.Braces, expressions);
            } else if (nextTokenType() == CASE) {
                // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1351:3
                pushOntoCallStack("parseAtom", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1351, 3);
                try {
                    expression = parseCaseExpression();
                } finally {
                    popCallStack();
                }
                // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1352:3
                return expression;
            } else if (first_set$Grammer_ccc$1358$3.contains(nextTokenType())) {
                // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1358:3
                pushOntoCallStack("parseAtom", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1358, 3);
                try {
                    // Function call "foo(a, b)" or "whiz!bang!foo(a, b)".
                    // Properties "x.PROP" and methods "exp.meth(a)" are in primary().
                    nameObjectIdentifier = parseNameObjectIdentifier();
                } finally {
                    popCallStack();
                }
                // Code for ZeroOrMore specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1359:3
                while (true) {
                    if (!(nextTokenType() == BANG)) break;
                    // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1360:5
                    consumeToken(BANG);
                    // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1360:14
                    pushOntoCallStack("parseAtom", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1360, 14);
                    try {
                        nameObjectIdentifier = parseNameObjectIdentifier();
                    } finally {
                        popCallStack();
                    }
                    // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1361:5
                    // We support the syntax for qualifying function names with package
                    // names separated by bang ('!'), e.g. 'whiz!bang!foo(a, b)'
                    // but currently we ignore the qualifiers. The previous example is
                    // equivalent to 'foo(a, b)'.
                }
                if (nextTokenType() == LPAREN) {
                    // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1369:5
                    consumeToken(LPAREN);
                    if (scan$Grammer_ccc$1371$7()) {
                        // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1372:7
                        expressions = Collections.emptyList();
                    } else {
                        // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1376:7
                        pushOntoCallStack("parseAtom", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1376, 7);
                        try {
                            expressions = expOrEmptyList();
                        } finally {
                            popCallStack();
                        }
                    }
                    // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1378:5
                    consumeToken(RPAREN);
                } else {
                    // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1380:16
                    expressions = null;
                }
                // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1384:3
                return MdxParserUtil.createCall(null, nameObjectIdentifier, expressions);
            } else {
                pushOntoCallStack("parseAtom", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1302, 3);
                throw new ParseException(lastConsumedToken, parseAtom_FIRST_SET, parsingStack);
            }
        } catch (ParseException e) {
            parseException1751 = e;
            throw e;
        } finally {
            restoreCallStack(callStackSize1752);
            if (thisProduction != null) {
                if (parseException1751 == null) {
                    closeNodeScope(thisProduction, nodeArity() > 1);
                } else {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction = prevProduction;
        }
    }

    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1390:1
    final public Expression parseCaseExpression() {
        if (cancelled) throw new CancellationException();
        String prevProduction = currentlyParsedProduction;
        this.currentlyParsedProduction = "parseCaseExpression";
        ASTparseCaseExpression thisProduction = null;
        if (buildTree) {
            thisProduction = new ASTparseCaseExpression();
            openNodeScope(thisProduction);
        }
        Expression expression, expression2;
        List<Expression> expressions = new ArrayList<Expression>();
        boolean match = false;
        ParseException parseException1982 = null;
        int callStackSize1983 = parsingStack.size();
        try {
            // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1396:3
            consumeToken(CASE);
            // Code for ZeroOrOne specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1397:3
            if (first_set$Grammer_ccc$1398$5.contains(nextTokenType())) {
                // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1398:5
                pushOntoCallStack("parseCaseExpression", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1398, 5);
                try {
                    expression = parseExpression();
                } finally {
                    popCallStack();
                }
                // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1399:5
                match = true;
                expressions.add(expression);
            }
            // Code for ZeroOrMore specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1404:3
            while (true) {
                if (!(nextTokenType() == WHEN)) break;
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1405:5
                consumeToken(WHEN);
                // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1405:14
                pushOntoCallStack("parseCaseExpression", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1405, 14);
                try {
                    expression = parseExpression();
                } finally {
                    popCallStack();
                }
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1405:43
                consumeToken(THEN);
                // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1405:52
                pushOntoCallStack("parseCaseExpression", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1405, 52);
                try {
                    expression2 = parseExpression();
                } finally {
                    popCallStack();
                }
                // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1406:5
                expressions.add(expression);
                expressions.add(expression2);
            }
            // Code for ZeroOrOne specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1411:3
            if (nextTokenType() == ELSE) {
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1412:5
                consumeToken(ELSE);
                // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1412:14
                pushOntoCallStack("parseCaseExpression", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1412, 14);
                try {
                    expression = parseExpression();
                } finally {
                    popCallStack();
                }
                // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1413:5
                expressions.add(expression);
            }
            // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1417:3
            consumeToken(END);
            // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1418:3
            if (match) {
                return new CallExpressionR("_CaseMatch", CallExpression.Type.Term_Case, expressions);
            } else {
                return new CallExpressionR("_CaseTest", CallExpression.Type.Term_Case, expressions);
            }
        } catch (ParseException e) {
            parseException1982 = e;
            throw e;
        } finally {
            restoreCallStack(callStackSize1983);
            if (thisProduction != null) {
                if (parseException1982 == null) {
                    closeNodeScope(thisProduction, nodeArity() > 1);
                } else {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction = prevProduction;
        }
    }

    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1434:1
    final public CreateSetBodyClause parseCreateSetBodyClause() {
        if (cancelled) throw new CancellationException();
        String prevProduction = currentlyParsedProduction;
        this.currentlyParsedProduction = "parseCreateSetBodyClause";
        ASTparseCreateSetBodyClause thisProduction = null;
        if (buildTree) {
            thisProduction = new ASTparseCreateSetBodyClause();
            openNodeScope(thisProduction);
        }
        CompoundId compoundId = null;
        Expression expression = null;
        //List<MemberPropertyDefinition> memberPropertyDefinitions = new LinkedList<MemberPropertyDefinition>();
        //MemberPropertyDefinition memberPropertyDefinition = null;
        ParseException parseException2062 = null;
        int callStackSize2063 = parsingStack.size();
        try {
            // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1442:3
            pushOntoCallStack("parseCreateSetBodyClause", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1442, 3);
            try {
                compoundId = parseCompoundId();
            } finally {
                popCallStack();
            }
            // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1442:32
            consumeToken(AS);
            // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1442:39
            pushOntoCallStack("parseCreateSetBodyClause", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1442, 39);
            try {
                expression = parseExpression();
            } finally {
                popCallStack();
            }
            // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1443:3
            return new CreateSetBodyClauseR(compoundId, expression);
        } catch (ParseException e) {
            parseException2062 = e;
            throw e;
        } finally {
            restoreCallStack(callStackSize2063);
            if (thisProduction != null) {
                if (parseException2062 == null) {
                    closeNodeScope(thisProduction, nodeArity() > 1);
                } else {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction = prevProduction;
        }
    }

    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1449:1
    final public SelectDimensionPropertyListClause parseSelectDimensionPropertyListClause() {
        if (cancelled) throw new CancellationException();
        String prevProduction = currentlyParsedProduction;
        this.currentlyParsedProduction = "parseSelectDimensionPropertyListClause";
        ASTparseSelectDimensionPropertyListClause thisProduction = null;
        if (buildTree) {
            thisProduction = new ASTparseSelectDimensionPropertyListClause();
            openNodeScope(thisProduction);
        }
        ParseException parseException2082 = null;
        int callStackSize2083 = parsingStack.size();
        try {
            // Code for ZeroOrOne specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1450:3
            if (nextTokenType() == DIMENSION) {
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1450:4
                consumeToken(DIMENSION);
            }
            // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1451:3
            List<CompoundId> cellProperties = new LinkedList<CompoundId>();
            // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1454:3
            consumeToken(PROPERTIES);
            // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1455:3
            cellProperties.add(parseCompoundId());
            // Code for ZeroOrMore specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1458:3
            while (true) {
                if (!(nextTokenType() == COMMA)) break;
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1459:5
                consumeToken(COMMA);
                // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1460:5
                cellProperties.add(parseCompoundId());
            }
            // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1464:3
            return new SelectDimensionPropertyListClauseR(cellProperties);
        } catch (ParseException e) {
            parseException2082 = e;
            throw e;
        } finally {
            restoreCallStack(callStackSize2083);
            if (thisProduction != null) {
                if (parseException2082 == null) {
                    closeNodeScope(thisProduction, nodeArity() > 1);
                } else {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction = prevProduction;
        }
    }

    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1470:1
    final public RefreshStatement parseRefreshStatement() {
        if (cancelled) throw new CancellationException();
        String prevProduction = currentlyParsedProduction;
        this.currentlyParsedProduction = "parseRefreshStatement";
        ASTparseRefreshStatement thisProduction = null;
        if (buildTree) {
            thisProduction = new ASTparseRefreshStatement();
            openNodeScope(thisProduction);
        }
        NameObjectIdentifier cubeName;
        ParseException parseException2130 = null;
        int callStackSize2131 = parsingStack.size();
        try {
            // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1474:3
            consumeToken(REFRESH);
            // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1474:15
            consumeToken(CUBE);
            // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1474:25
            pushOntoCallStack("parseRefreshStatement", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1474, 25);
            try {
                cubeName = parseNameObjectIdentifier();
            } finally {
                popCallStack();
            }
            // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1475:1
            return new RefreshStatementR(cubeName);
        } catch (ParseException e) {
            parseException2130 = e;
            throw e;
        } finally {
            restoreCallStack(callStackSize2131);
            if (thisProduction != null) {
                if (parseException2130 == null) {
                    closeNodeScope(thisProduction, nodeArity() > 1);
                } else {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction = prevProduction;
        }
    }

    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1481:1
    final public
    // <SelectQueryAxisClause> ::= [NON EMPTY] <set> [<dimProps>] ON <axis_name>
    SelectQueryAxisClause parseSelectQueryAxisClause() {
        if (cancelled) throw new CancellationException();
        String prevProduction = currentlyParsedProduction;
        this.currentlyParsedProduction = "parseSelectQueryAxisClause";
        ASTparseSelectQueryAxisClause thisProduction = null;
        if (buildTree) {
            thisProduction = new ASTparseSelectQueryAxisClause();
            openNodeScope(thisProduction);
        }
        boolean nonEmpty = false;
        SelectDimensionPropertyListClause selectDimensionPropertyListClause = null;
        Expression expression;
        int n;
        Axis axis;
        ParseException parseException2150 = null;
        int callStackSize2151 = parsingStack.size();
        try {
            // Code for ZeroOrOne specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1489:3
            if (nextTokenType() == NON) {
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1489:4
                consumeToken(NON);
                // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1489:12
                consumeToken(EMPTY);
                // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1490:3
                nonEmpty = true;
            }
            // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1494:3
            pushOntoCallStack("parseSelectQueryAxisClause", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1494, 3);
            try {
                expression = parseExpression();
            } finally {
                popCallStack();
            }
            // Code for ZeroOrOne specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1495:3
            if (nextTokenType() == DIMENSION || nextTokenType == PROPERTIES) {
                // Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1496:5
                pushOntoCallStack("parseSelectQueryAxisClause", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1496, 5);
                try {
                    selectDimensionPropertyListClause = parseSelectDimensionPropertyListClause();
                } finally {
                    popCallStack();
                }
            }
            // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1498:3
            consumeToken(ON);
            if (nextTokenType() == AXIS || nextTokenType == UNSIGNED_INTEGER_LITERAL) {
                if (nextTokenType() == UNSIGNED_INTEGER_LITERAL) {
                    // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1501:7
                    consumeToken(UNSIGNED_INTEGER_LITERAL);
                    // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1502:7
                    n = Integer.valueOf(getToken(0).getImage()).intValue();
                } else if (nextTokenType() == AXIS) {
                    // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1505:7
                    consumeToken(AXIS);
                    // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1505:16
                    consumeToken(LPAREN);
                    // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1505:27
                    consumeToken(UNSIGNED_INTEGER_LITERAL);
                    // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1506:7
                    n = Integer.valueOf(getToken(0).getImage()).intValue();
                    // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1509:7
                    consumeToken(RPAREN);
                } else {
                    pushOntoCallStack("parseSelectQueryAxisClause", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1501, 7);
                    throw new ParseException(lastConsumedToken, first_set$Grammer_ccc$1501$7, parsingStack);
                }
                // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1511:5
                if (n < 0) {
                    throw new IllegalArgumentException("Only axis numbers >= 0 allowed.");
                } else {
                    axis = AxisR.createUnnamed(n);
                }
            } else if (first_set$Grammer_ccc$1522$5.contains(nextTokenType())) {
                if (nextTokenType() == COLUMNS) {
                    // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1523:7
                    consumeToken(COLUMNS);
                    // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1524:7
                    axis = AxisR.COLUMNS_NAMED;
                } else if (nextTokenType() == ROWS) {
                    // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1527:7
                    consumeToken(ROWS);
                    // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1528:7
                    axis = AxisR.ROWS_NAMED;
                } else if (nextTokenType() == PAGES) {
                    // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1531:7
                    consumeToken(PAGES);
                    // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1532:7
                    axis = AxisR.PAGES_NAMED;
                } else if (nextTokenType() == SECTIONS) {
                    // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1535:7
                    consumeToken(SECTIONS);
                    // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1536:7
                    axis = AxisR.SECTIONS_NAMED;
                } else if (nextTokenType() == CHAPTERS) {
                    // Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1539:7
                    consumeToken(CHAPTERS);
                    // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1540:7
                    axis = AxisR.CHAPTERS_NAMED;
                } else {
                    pushOntoCallStack("parseSelectQueryAxisClause", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1523, 7);
                    throw new ParseException(lastConsumedToken, first_set$Grammer_ccc$1523$7, parsingStack);
                }
            } else {
                pushOntoCallStack("parseSelectQueryAxisClause", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1500, 5);
                throw new ParseException(lastConsumedToken, first_set$Grammer_ccc$1500$5, parsingStack);
            }
            // Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1545:3
            return new SelectQueryAxisClauseR(nonEmpty, expression, axis, selectDimensionPropertyListClause);
        } catch (ParseException e) {
            parseException2150 = e;
            throw e;
        } finally {
            restoreCallStack(callStackSize2151);
            if (thisProduction != null) {
                if (parseException2150 == null) {
                    closeNodeScope(thisProduction, nodeArity() > 1);
                } else {
                    clearNodeScope();
                }
            }
            this.currentlyParsedProduction = prevProduction;
        }
    }

    static private final EnumSet<TokenType> first_set$Grammer_ccc$466$5 = tokenTypeSet(DRILLTHROUGH, SELECT, WITH);
    static private final EnumSet<TokenType> first_set$Grammer_ccc$535$5 = tokenTypeSet(CELL, MEMBER, MEASURE, SET, CALCULATED);
    static private final EnumSet<TokenType> first_set$Grammer_ccc$562$8 = tokenTypeSet(CELL, MEMBER, MEASURE, SET, CALCULATED);
    static private final EnumSet<TokenType> first_set$Grammer_ccc$573$5 = first_set$Grammer_ccc$573$5_init();

    static private EnumSet<TokenType> first_set$Grammer_ccc$573$5_init() {
        return tokenTypeSet(CASE, CAST, DIMENSION, NON, NOT, NULL, PROPERTIES, EXISTING, LPAREN, LBRACE, MINUS, PLUS, ATSIGN, ID, QUOTED_ID, UNSIGNED_INTEGER_LITERAL, APPROX_NUMERIC_LITERAL, DECIMAL_NUMERIC_LITERAL, SINGLE_QUOTED_STRING, DOUBLE_QUOTED_STRING);
    }

    static private final EnumSet<TokenType> first_set$Grammer_ccc$597$5$ = tokenTypeSet(DIMENSION, PROPERTIES, LPAREN, ATSIGN, ID, QUOTED_ID);
    static private final EnumSet<TokenType> first_set$Grammer_ccc$597$5 = tokenTypeSet(DIMENSION, PROPERTIES, ATSIGN, ID, QUOTED_ID);
    static private final EnumSet<TokenType> first_set$Grammer_ccc$629$7 = first_set$Grammer_ccc$629$7_init();

    static private EnumSet<TokenType> first_set$Grammer_ccc$629$7_init() {
        return tokenTypeSet(CASE, CAST, DIMENSION, NON, NOT, NULL, PROPERTIES, EXISTING, LPAREN, LBRACE, MINUS, PLUS, ATSIGN, ID, QUOTED_ID, UNSIGNED_INTEGER_LITERAL, APPROX_NUMERIC_LITERAL, DECIMAL_NUMERIC_LITERAL, SINGLE_QUOTED_STRING, DOUBLE_QUOTED_STRING);
    }

    static private final EnumSet<TokenType> first_set$Grammer_ccc$787$3 = first_set$Grammer_ccc$787$3_init();

    static private EnumSet<TokenType> first_set$Grammer_ccc$787$3_init() {
        return tokenTypeSet(CASE, CAST, DIMENSION, NOT, NULL, PROPERTIES, EXISTING, LPAREN, LBRACE, MINUS, PLUS, ATSIGN, ID, QUOTED_ID, UNSIGNED_INTEGER_LITERAL, APPROX_NUMERIC_LITERAL, DECIMAL_NUMERIC_LITERAL, SINGLE_QUOTED_STRING, DOUBLE_QUOTED_STRING);
    }

    static private final EnumSet<TokenType> first_set$Grammer_ccc$862$5$ = tokenTypeSet(DIMENSION, PROPERTIES, ATSIGN, ID, QUOTED_ID, AMP_QUOTED_ID, AMP_UNQUOTED_ID);
    static private final EnumSet<TokenType> first_set$Grammer_ccc$862$5 = tokenTypeSet(DIMENSION, PROPERTIES, ATSIGN, ID, QUOTED_ID);
    static private final EnumSet<TokenType> first_set$Grammer_ccc$936$5 = tokenTypeSet(DIMENSION, PROPERTIES);
    static private final EnumSet<TokenType> first_set$Grammer_ccc$1030$3 = first_set$Grammer_ccc$1030$3_init();

    static private EnumSet<TokenType> first_set$Grammer_ccc$1030$3_init() {
        return tokenTypeSet(CASE, CAST, DIMENSION, NULL, PROPERTIES, EXISTING, LPAREN, LBRACE, MINUS, PLUS, ATSIGN, ID, QUOTED_ID, UNSIGNED_INTEGER_LITERAL, APPROX_NUMERIC_LITERAL, DECIMAL_NUMERIC_LITERAL, SINGLE_QUOTED_STRING, DOUBLE_QUOTED_STRING);
    }

    static private final EnumSet<TokenType> first_set$Grammer_ccc$1052$5 = tokenTypeSet(EQ, GE, GT, LE, LT, NE);
    static private final EnumSet<TokenType> first_set$Grammer_ccc$1053$7 = tokenTypeSet(EQ, GE, GT, LE, LT, NE);
    static private final EnumSet<TokenType> first_set$Grammer_ccc$1222$3 = first_set$Grammer_ccc$1222$3_init();

    static private EnumSet<TokenType> first_set$Grammer_ccc$1222$3_init() {
        return tokenTypeSet(CASE, CAST, DIMENSION, NULL, PROPERTIES, LPAREN, LBRACE, ATSIGN, ID, QUOTED_ID, UNSIGNED_INTEGER_LITERAL, APPROX_NUMERIC_LITERAL, DECIMAL_NUMERIC_LITERAL, SINGLE_QUOTED_STRING, DOUBLE_QUOTED_STRING);
    }

    static private final EnumSet<TokenType> first_set$Grammer_ccc$1339$5 = first_set$Grammer_ccc$1339$5_init();

    static private EnumSet<TokenType> first_set$Grammer_ccc$1339$5_init() {
        return tokenTypeSet(CASE, CAST, DIMENSION, NOT, NULL, PROPERTIES, EXISTING, LPAREN, LBRACE, MINUS, PLUS, ATSIGN, ID, QUOTED_ID, UNSIGNED_INTEGER_LITERAL, APPROX_NUMERIC_LITERAL, DECIMAL_NUMERIC_LITERAL, SINGLE_QUOTED_STRING, DOUBLE_QUOTED_STRING);
    }

    static private final EnumSet<TokenType> first_set$Grammer_ccc$1344$5 = first_set$Grammer_ccc$1344$5_init();

    static private EnumSet<TokenType> first_set$Grammer_ccc$1344$5_init() {
        return tokenTypeSet(CASE, CAST, DIMENSION, NOT, NULL, PROPERTIES, EXISTING, LPAREN, LBRACE, MINUS, PLUS, ATSIGN, ID, QUOTED_ID, UNSIGNED_INTEGER_LITERAL, APPROX_NUMERIC_LITERAL, DECIMAL_NUMERIC_LITERAL, SINGLE_QUOTED_STRING, DOUBLE_QUOTED_STRING);
    }

    static private final EnumSet<TokenType> first_set$Grammer_ccc$1358$3 = tokenTypeSet(DIMENSION, PROPERTIES, ATSIGN, ID, QUOTED_ID);
    static private final EnumSet<TokenType> first_set$Grammer_ccc$1398$5 = first_set$Grammer_ccc$1398$5_init();

    static private EnumSet<TokenType> first_set$Grammer_ccc$1398$5_init() {
        return tokenTypeSet(CASE, CAST, DIMENSION, NOT, NULL, PROPERTIES, EXISTING, LPAREN, LBRACE, MINUS, PLUS, ATSIGN, ID, QUOTED_ID, UNSIGNED_INTEGER_LITERAL, APPROX_NUMERIC_LITERAL, DECIMAL_NUMERIC_LITERAL, SINGLE_QUOTED_STRING, DOUBLE_QUOTED_STRING);
    }

    static private final EnumSet<TokenType> first_set$Grammer_ccc$1500$5 = tokenTypeSet(AXIS, CHAPTERS, COLUMNS, PAGES, ROWS, SECTIONS, UNSIGNED_INTEGER_LITERAL);
    static private final EnumSet<TokenType> first_set$Grammer_ccc$1501$7 = tokenTypeSet(AXIS, UNSIGNED_INTEGER_LITERAL);
    static private final EnumSet<TokenType> first_set$Grammer_ccc$1522$5 = tokenTypeSet(CHAPTERS, COLUMNS, PAGES, ROWS, SECTIONS);
    static private final EnumSet<TokenType> first_set$Grammer_ccc$1523$7 = tokenTypeSet(CHAPTERS, COLUMNS, PAGES, ROWS, SECTIONS);

    private final boolean scanToken(TokenType expectedType, TokenType...additionalTypes) {
        Token peekedToken = nextToken(currentLookaheadToken);
        TokenType type = peekedToken.getType();
        if (type != expectedType) {
            boolean matched = false;
            for (TokenType tt : additionalTypes) {
                if (type == tt) {
                    matched = true;
                    break;
                }
            }
            if (!matched) return false;
        }
        --remainingLookahead;
        currentLookaheadToken = peekedToken;
        return true;
    }

    private final boolean scanToken(EnumSet<TokenType> types) {
        Token peekedToken = nextToken(currentLookaheadToken);
        TokenType type = peekedToken.getType();
        if (!types.contains(type)) return false;
        --remainingLookahead;
        currentLookaheadToken = peekedToken;
        return true;
    }

    // scanahead routine for expansion at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:768:5
    // BuildScanRoutine macro
    private final boolean check$Grammer_ccc$768$5(boolean scanToEnd) {
        boolean $reachedScanCode$ = false;
        int passedPredicateThreshold = remainingLookahead - 1;
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            $reachedScanCode$ = true;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:768:5
            if (!scanToken(AS)) return false;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:768:12
            // NonTerminal parseIdentifier at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:768:12
            pushOntoLookaheadStack("parseExpression", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 768, 12);
            currentLookaheadProduction = "parseIdentifier";
            try {
                if (!check$parseIdentifier(true)) return false;
            } finally {
                popLookaheadStack();
            }
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:769:5
        } finally {
            lookaheadRoutineNesting--;
            if ($reachedScanCode$ && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true;
            }
        }
        passedPredicate = false;
        return true;
    }

    // scanahead routine for expansion at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:787:3
    // BuildScanRoutine macro
    private final boolean check$Grammer_ccc$787$3(boolean scanToEnd) {
        boolean $reachedScanCode$ = false;
        int passedPredicateThreshold = remainingLookahead - 1;
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            $reachedScanCode$ = true;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:787:3
            // NonTerminal parseExpression at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:787:3
            pushOntoLookaheadStack("parseExpressionOrEmpty", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 787, 3);
            currentLookaheadProduction = "parseExpression";
            try {
                if (!check$parseExpression(false)) return false;
            } finally {
                popLookaheadStack();
            }
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:788:3
        } finally {
            lookaheadRoutineNesting--;
            if ($reachedScanCode$ && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true;
            }
        }
        passedPredicate = false;
        return true;
    }

    // scanahead routine for expansion at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:792:3
    // BuildScanRoutine macro
    private final boolean check$Grammer_ccc$792$3(boolean scanToEnd) {
        boolean $reachedScanCode$ = false;
        int passedPredicateThreshold = remainingLookahead - 1;
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            $reachedScanCode$ = true;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:792:3
        } finally {
            lookaheadRoutineNesting--;
            if ($reachedScanCode$ && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true;
            }
        }
        passedPredicate = false;
        return true;
    }

    // scanahead routine for expansion at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:811:5
    // BuildScanRoutine macro
    private final boolean check$Grammer_ccc$811$5(boolean scanToEnd) {
        boolean $reachedScanCode$ = false;
        int passedPredicateThreshold = remainingLookahead - 1;
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            $reachedScanCode$ = true;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:811:5
            if (!scanToken(COMMA)) return false;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:812:5
            // NonTerminal parseExpressionOrEmpty at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:812:5
            pushOntoLookaheadStack("expOrEmptyList", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 812, 5);
            currentLookaheadProduction = "parseExpressionOrEmpty";
            try {
                if (!check$parseExpressionOrEmpty(true)) return false;
            } finally {
                popLookaheadStack();
            }
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:813:5
        } finally {
            lookaheadRoutineNesting--;
            if ($reachedScanCode$ && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true;
            }
        }
        passedPredicate = false;
        return true;
    }

    // scanahead routine for expansion at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:834:5
    // BuildScanRoutine macro
    private final boolean check$Grammer_ccc$834$5(boolean scanToEnd) {
        boolean $reachedScanCode$ = false;
        int passedPredicateThreshold = remainingLookahead - 1;
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            $reachedScanCode$ = true;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:834:5
            if (!scanToken(COMMA)) return false;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:835:5
            // NonTerminal parseExpression at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:835:5
            pushOntoLookaheadStack("expList", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 835, 5);
            currentLookaheadProduction = "parseExpression";
            try {
                if (!check$parseExpression(true)) return false;
            } finally {
                popLookaheadStack();
            }
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:836:5
        } finally {
            lookaheadRoutineNesting--;
            if ($reachedScanCode$ && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true;
            }
        }
        passedPredicate = false;
        return true;
    }

    // scanahead routine for expansion at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:862:5
    // BuildScanRoutine macro
    private final boolean check$Grammer_ccc$862$5$(boolean scanToEnd) {
        boolean $reachedScanCode$ = false;
        int passedPredicateThreshold = remainingLookahead - 1;
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            $reachedScanCode$ = true;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:862:5
            // NonTerminal parseNameObjectIdentifier at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:862:5
            pushOntoLookaheadStack("parseIdentifier", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 862, 5);
            currentLookaheadProduction = "parseNameObjectIdentifier";
            try {
                if (!check$parseNameObjectIdentifier(false)) return false;
            } finally {
                popLookaheadStack();
            }
        } finally {
            lookaheadRoutineNesting--;
            if ($reachedScanCode$ && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true;
            }
        }
        passedPredicate = false;
        return true;
    }

    // scanahead routine for expansion at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:864:5
    // BuildScanRoutine macro
    private final boolean check$Grammer_ccc$864$5(boolean scanToEnd) {
        boolean $reachedScanCode$ = false;
        int passedPredicateThreshold = remainingLookahead - 1;
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            $reachedScanCode$ = true;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:864:5
            // NonTerminal parseKeyIdentifier at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:864:5
            pushOntoLookaheadStack("parseIdentifier", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 864, 5);
            currentLookaheadProduction = "parseKeyIdentifier";
            try {
                if (!check$parseKeyIdentifier(false)) return false;
            } finally {
                popLookaheadStack();
            }
        } finally {
            lookaheadRoutineNesting--;
            if ($reachedScanCode$ && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true;
            }
        }
        passedPredicate = false;
        return true;
    }

    // scanahead routine for expansion at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:885:3
    // BuildScanRoutine macro
    private final boolean check$Grammer_ccc$885$3(boolean scanToEnd) {
        boolean $reachedScanCode$ = false;
        int passedPredicateThreshold = remainingLookahead - 1;
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            $reachedScanCode$ = true;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:885:3
            if (!scanToken(ATSIGN)) return false;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:885:14
            if (!scanToken(ID)) return false;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:886:3
        } finally {
            lookaheadRoutineNesting--;
            if ($reachedScanCode$ && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true;
            }
        }
        passedPredicate = false;
        return true;
    }

    // scanahead routine for expansion at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:976:5
    // BuildScanRoutine macro
    private final boolean check$Grammer_ccc$976$5(boolean scanToEnd) {
        boolean $reachedScanCode$ = false;
        int passedPredicateThreshold = remainingLookahead - 1;
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            $reachedScanCode$ = true;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for ExpansionChoice specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:976:5
            Token token2442 = currentLookaheadToken;
            int remainingLookahead2442 = remainingLookahead;
            boolean hitFailure2442 = hitFailure, passedPredicate2442 = passedPredicate;
            try {
                passedPredicate = false;
                if (!check$Grammer_ccc$976$5$(false)) {
                    currentLookaheadToken = token2442;
                    remainingLookahead = remainingLookahead2442;
                    hitFailure = hitFailure2442;
                    if (passedPredicate && !legacyGlitchyLookahead) return false;
                    passedPredicate = false;
                    if (!check$Grammer_ccc$983$5(false)) {
                        currentLookaheadToken = token2442;
                        remainingLookahead = remainingLookahead2442;
                        hitFailure = hitFailure2442;
                        if (passedPredicate && !legacyGlitchyLookahead) return false;
                        passedPredicate = false;
                        if (!check$Grammer_ccc$992$5(false)) {
                            currentLookaheadToken = token2442;
                            remainingLookahead = remainingLookahead2442;
                            hitFailure = hitFailure2442;
                            return false;
                        }
                    }
                }
            } finally {
                passedPredicate = passedPredicate2442;
            }
        } finally {
            lookaheadRoutineNesting--;
            if ($reachedScanCode$ && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true;
            }
        }
        passedPredicate = false;
        return true;
    }

    // scanahead routine for expansion at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:976:5
    // BuildScanRoutine macro
    private final boolean check$Grammer_ccc$976$5$(boolean scanToEnd) {
        boolean $reachedScanCode$ = false;
        int passedPredicateThreshold = remainingLookahead - 1;
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            $reachedScanCode$ = true;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:976:5
            if (!scanToken(OR)) return false;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:976:12
            // NonTerminal parseTerm5 at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:976:12
            pushOntoLookaheadStack("parseUnaliasedExpression", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 976, 12);
            currentLookaheadProduction = "parseTerm5";
            try {
                if (!check$parseTerm5(true)) return false;
            } finally {
                popLookaheadStack();
            }
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:977:5
        } finally {
            lookaheadRoutineNesting--;
            if ($reachedScanCode$ && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true;
            }
        }
        passedPredicate = false;
        return true;
    }

    // scanahead routine for expansion at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:983:5
    // BuildScanRoutine macro
    private final boolean check$Grammer_ccc$983$5(boolean scanToEnd) {
        boolean $reachedScanCode$ = false;
        int passedPredicateThreshold = remainingLookahead - 1;
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            $reachedScanCode$ = true;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:983:5
            if (!scanToken(XOR)) return false;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:983:13
            // NonTerminal parseTerm5 at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:983:13
            pushOntoLookaheadStack("parseUnaliasedExpression", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 983, 13);
            currentLookaheadProduction = "parseTerm5";
            try {
                if (!check$parseTerm5(true)) return false;
            } finally {
                popLookaheadStack();
            }
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:984:5
        } finally {
            lookaheadRoutineNesting--;
            if ($reachedScanCode$ && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true;
            }
        }
        passedPredicate = false;
        return true;
    }

    // scanahead routine for expansion at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:992:5
    // BuildScanRoutine macro
    private final boolean check$Grammer_ccc$992$5(boolean scanToEnd) {
        boolean $reachedScanCode$ = false;
        int passedPredicateThreshold = remainingLookahead - 1;
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            $reachedScanCode$ = true;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:992:5
            if (!scanToken(COLON)) return false;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:992:15
            // NonTerminal parseTerm5 at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:992:15
            pushOntoLookaheadStack("parseUnaliasedExpression", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 992, 15);
            currentLookaheadProduction = "parseTerm5";
            try {
                if (!check$parseTerm5(true)) return false;
            } finally {
                popLookaheadStack();
            }
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:993:5
        } finally {
            lookaheadRoutineNesting--;
            if ($reachedScanCode$ && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true;
            }
        }
        passedPredicate = false;
        return true;
    }

    // scanahead routine for expansion at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1012:5
    // BuildScanRoutine macro
    private final boolean check$Grammer_ccc$1012$5(boolean scanToEnd) {
        boolean $reachedScanCode$ = false;
        int passedPredicateThreshold = remainingLookahead - 1;
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            $reachedScanCode$ = true;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1012:5
            if (!scanToken(AND)) return false;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1012:13
            // NonTerminal parseTerm4 at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1012:13
            pushOntoLookaheadStack("parseTerm5", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1012, 13);
            currentLookaheadProduction = "parseTerm4";
            try {
                if (!check$parseTerm4(true)) return false;
            } finally {
                popLookaheadStack();
            }
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1013:5
        } finally {
            lookaheadRoutineNesting--;
            if ($reachedScanCode$ && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true;
            }
        }
        passedPredicate = false;
        return true;
    }

    // scanahead routine for expansion at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1030:3
    // BuildScanRoutine macro
    private final boolean check$Grammer_ccc$1030$3(boolean scanToEnd) {
        boolean $reachedScanCode$ = false;
        int passedPredicateThreshold = remainingLookahead - 1;
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            $reachedScanCode$ = true;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1030:3
            // NonTerminal parseTerm3 at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1030:3
            pushOntoLookaheadStack("parseTerm4", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1030, 3);
            currentLookaheadProduction = "parseTerm3";
            try {
                if (!check$parseTerm3(false)) return false;
            } finally {
                popLookaheadStack();
            }
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1031:3
        } finally {
            lookaheadRoutineNesting--;
            if ($reachedScanCode$ && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true;
            }
        }
        passedPredicate = false;
        return true;
    }

    // scanahead routine for expansion at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1034:3
    // BuildScanRoutine macro
    private final boolean check$Grammer_ccc$1034$3(boolean scanToEnd) {
        boolean $reachedScanCode$ = false;
        int passedPredicateThreshold = remainingLookahead - 1;
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            $reachedScanCode$ = true;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1034:3
            if (!scanToken(NOT)) return false;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1034:11
            // NonTerminal parseTerm4 at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1034:11
            pushOntoLookaheadStack("parseTerm4", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1034, 11);
            currentLookaheadProduction = "parseTerm4";
            try {
                if (!check$parseTerm4(true)) return false;
            } finally {
                popLookaheadStack();
            }
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1035:3
        } finally {
            lookaheadRoutineNesting--;
            if ($reachedScanCode$ && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true;
            }
        }
        passedPredicate = false;
        return true;
    }

    // scanahead routine for expansion at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1052:5
    // BuildScanRoutine macro
    private final boolean check$Grammer_ccc$1052$5(boolean scanToEnd) {
        boolean $reachedScanCode$ = false;
        int passedPredicateThreshold = remainingLookahead - 1;
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            $reachedScanCode$ = true;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for ExpansionChoice specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1052:5
            Token token2467 = currentLookaheadToken;
            int remainingLookahead2467 = remainingLookahead;
            boolean hitFailure2467 = hitFailure, passedPredicate2467 = passedPredicate;
            try {
                passedPredicate = false;
                if (!check$Grammer_ccc$1052$5$(false)) {
                    currentLookaheadToken = token2467;
                    remainingLookahead = remainingLookahead2467;
                    hitFailure = hitFailure2467;
                    if (passedPredicate && !legacyGlitchyLookahead) return false;
                    passedPredicate = false;
                    if (!check$Grammer_ccc$1088$5(false)) {
                        currentLookaheadToken = token2467;
                        remainingLookahead = remainingLookahead2467;
                        hitFailure = hitFailure2467;
                        if (passedPredicate && !legacyGlitchyLookahead) return false;
                        passedPredicate = false;
                        if (!check$Grammer_ccc$1098$5(false)) {
                            currentLookaheadToken = token2467;
                            remainingLookahead = remainingLookahead2467;
                            hitFailure = hitFailure2467;
                            if (passedPredicate && !legacyGlitchyLookahead) return false;
                            passedPredicate = false;
                            if (!check$Grammer_ccc$1106$5(false)) {
                                currentLookaheadToken = token2467;
                                remainingLookahead = remainingLookahead2467;
                                hitFailure = hitFailure2467;
                                if (passedPredicate && !legacyGlitchyLookahead) return false;
                                passedPredicate = false;
                                if (!check$Grammer_ccc$1111$5(false)) {
                                    currentLookaheadToken = token2467;
                                    remainingLookahead = remainingLookahead2467;
                                    hitFailure = hitFailure2467;
                                    if (passedPredicate && !legacyGlitchyLookahead) return false;
                                    passedPredicate = false;
                                    if (!check$Grammer_ccc$1118$5(false)) {
                                        currentLookaheadToken = token2467;
                                        remainingLookahead = remainingLookahead2467;
                                        hitFailure = hitFailure2467;
                                        if (passedPredicate && !legacyGlitchyLookahead) return false;
                                        passedPredicate = false;
                                        if (!check$Grammer_ccc$1131$5(false)) {
                                            currentLookaheadToken = token2467;
                                            remainingLookahead = remainingLookahead2467;
                                            hitFailure = hitFailure2467;
                                            if (passedPredicate && !legacyGlitchyLookahead) return false;
                                            passedPredicate = false;
                                            if (!check$Grammer_ccc$1138$5(false)) {
                                                currentLookaheadToken = token2467;
                                                remainingLookahead = remainingLookahead2467;
                                                hitFailure = hitFailure2467;
                                                return false;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } finally {
                passedPredicate = passedPredicate2467;
            }
        } finally {
            lookaheadRoutineNesting--;
            if ($reachedScanCode$ && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true;
            }
        }
        passedPredicate = false;
        return true;
    }

    // scanahead routine for expansion at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1052:5
    // BuildScanRoutine macro
    private final boolean check$Grammer_ccc$1052$5$(boolean scanToEnd) {
        boolean $reachedScanCode$ = false;
        int passedPredicateThreshold = remainingLookahead - 1;
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            $reachedScanCode$ = true;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for ExpansionChoice specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1053:7
            if (!scanToken(first_set$Grammer_ccc$1053$7)) return false;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1078:5
            // NonTerminal parseTerm2 at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1078:5
            pushOntoLookaheadStack("parseTerm3", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1078, 5);
            currentLookaheadProduction = "parseTerm2";
            try {
                if (!check$parseTerm2(true)) return false;
            } finally {
                popLookaheadStack();
            }
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1079:5
        } finally {
            lookaheadRoutineNesting--;
            if ($reachedScanCode$ && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true;
            }
        }
        passedPredicate = false;
        return true;
    }

    // scanahead routine for expansion at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1088:5
    // BuildScanRoutine macro
    private final boolean check$Grammer_ccc$1088$5(boolean scanToEnd) {
        boolean $reachedScanCode$ = false;
        int passedPredicateThreshold = remainingLookahead - 2;
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            $reachedScanCode$ = true;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1089:5
            if (!scanToken(IS)) return false;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1089:12
            if (!scanToken(NULL)) return false;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1090:5
        } finally {
            lookaheadRoutineNesting--;
            if ($reachedScanCode$ && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true;
            }
        }
        passedPredicate = false;
        return true;
    }

    // scanahead routine for expansion at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1098:5
    // BuildScanRoutine macro
    private final boolean check$Grammer_ccc$1098$5(boolean scanToEnd) {
        boolean $reachedScanCode$ = false;
        int passedPredicateThreshold = remainingLookahead - 2;
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            $reachedScanCode$ = true;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1099:5
            if (!scanToken(IS)) return false;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1099:12
            // NonTerminal parseTerm2 at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1099:12
            pushOntoLookaheadStack("parseTerm3", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1099, 12);
            currentLookaheadProduction = "parseTerm2";
            try {
                if (!check$parseTerm2(true)) return false;
            } finally {
                popLookaheadStack();
            }
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1100:5
        } finally {
            lookaheadRoutineNesting--;
            if ($reachedScanCode$ && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true;
            }
        }
        passedPredicate = false;
        return true;
    }

    // scanahead routine for expansion at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1106:5
    // BuildScanRoutine macro
    private final boolean check$Grammer_ccc$1106$5(boolean scanToEnd) {
        boolean $reachedScanCode$ = false;
        int passedPredicateThreshold = remainingLookahead - 1;
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            $reachedScanCode$ = true;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1106:5
            if (!scanToken(IS)) return false;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1106:12
            if (!scanToken(EMPTY)) return false;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1107:5
        } finally {
            lookaheadRoutineNesting--;
            if ($reachedScanCode$ && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true;
            }
        }
        passedPredicate = false;
        return true;
    }

    // scanahead routine for expansion at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1111:5
    // BuildScanRoutine macro
    private final boolean check$Grammer_ccc$1111$5(boolean scanToEnd) {
        boolean $reachedScanCode$ = false;
        int passedPredicateThreshold = remainingLookahead - 1;
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            $reachedScanCode$ = true;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1111:5
            if (!scanToken(MATCHES)) return false;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1111:17
            // NonTerminal parseTerm2 at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1111:17
            pushOntoLookaheadStack("parseTerm3", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1111, 17);
            currentLookaheadProduction = "parseTerm2";
            try {
                if (!check$parseTerm2(true)) return false;
            } finally {
                popLookaheadStack();
            }
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1112:5
        } finally {
            lookaheadRoutineNesting--;
            if ($reachedScanCode$ && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true;
            }
        }
        passedPredicate = false;
        return true;
    }

    // scanahead routine for expansion at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1118:5
    // BuildScanRoutine macro
    private final boolean check$Grammer_ccc$1118$5(boolean scanToEnd) {
        boolean $reachedScanCode$ = false;
        int passedPredicateThreshold = remainingLookahead - 2;
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            $reachedScanCode$ = true;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1119:5
            if (!scanToken(NOT)) return false;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1119:13
            if (!scanToken(MATCHES)) return false;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1119:25
            // NonTerminal parseTerm2 at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1119:25
            pushOntoLookaheadStack("parseTerm3", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1119, 25);
            currentLookaheadProduction = "parseTerm2";
            try {
                if (!check$parseTerm2(true)) return false;
            } finally {
                popLookaheadStack();
            }
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1120:5
        } finally {
            lookaheadRoutineNesting--;
            if ($reachedScanCode$ && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true;
            }
        }
        passedPredicate = false;
        return true;
    }

    // scanahead routine for expansion at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1131:5
    // BuildScanRoutine macro
    private final boolean check$Grammer_ccc$1131$5(boolean scanToEnd) {
        boolean $reachedScanCode$ = false;
        int passedPredicateThreshold = remainingLookahead - 1;
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            $reachedScanCode$ = true;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1131:5
            if (!scanToken(IN)) return false;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1131:12
            // NonTerminal parseTerm2 at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1131:12
            pushOntoLookaheadStack("parseTerm3", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1131, 12);
            currentLookaheadProduction = "parseTerm2";
            try {
                if (!check$parseTerm2(true)) return false;
            } finally {
                popLookaheadStack();
            }
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1132:5
        } finally {
            lookaheadRoutineNesting--;
            if ($reachedScanCode$ && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true;
            }
        }
        passedPredicate = false;
        return true;
    }

    // scanahead routine for expansion at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1138:5
    // BuildScanRoutine macro
    private final boolean check$Grammer_ccc$1138$5(boolean scanToEnd) {
        boolean $reachedScanCode$ = false;
        int passedPredicateThreshold = remainingLookahead - 1;
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            $reachedScanCode$ = true;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1138:5
            if (!scanToken(NOT)) return false;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1138:13
            if (!scanToken(IN)) return false;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1138:20
            // NonTerminal parseTerm2 at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1138:20
            pushOntoLookaheadStack("parseTerm3", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1138, 20);
            currentLookaheadProduction = "parseTerm2";
            try {
                if (!check$parseTerm2(true)) return false;
            } finally {
                popLookaheadStack();
            }
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1139:5
        } finally {
            lookaheadRoutineNesting--;
            if ($reachedScanCode$ && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true;
            }
        }
        passedPredicate = false;
        return true;
    }

    // scanahead routine for expansion at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1163:5
    // BuildScanRoutine macro
    private final boolean check$Grammer_ccc$1163$5(boolean scanToEnd) {
        boolean $reachedScanCode$ = false;
        int passedPredicateThreshold = remainingLookahead - 1;
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            $reachedScanCode$ = true;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for ExpansionChoice specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1163:5
            Token token2504 = currentLookaheadToken;
            int remainingLookahead2504 = remainingLookahead;
            boolean hitFailure2504 = hitFailure, passedPredicate2504 = passedPredicate;
            try {
                passedPredicate = false;
                if (!check$Grammer_ccc$1163$5$(false)) {
                    currentLookaheadToken = token2504;
                    remainingLookahead = remainingLookahead2504;
                    hitFailure = hitFailure2504;
                    if (passedPredicate && !legacyGlitchyLookahead) return false;
                    passedPredicate = false;
                    if (!check$Grammer_ccc$1170$5(false)) {
                        currentLookaheadToken = token2504;
                        remainingLookahead = remainingLookahead2504;
                        hitFailure = hitFailure2504;
                        if (passedPredicate && !legacyGlitchyLookahead) return false;
                        passedPredicate = false;
                        if (!check$Grammer_ccc$1177$5(false)) {
                            currentLookaheadToken = token2504;
                            remainingLookahead = remainingLookahead2504;
                            hitFailure = hitFailure2504;
                            return false;
                        }
                    }
                }
            } finally {
                passedPredicate = passedPredicate2504;
            }
        } finally {
            lookaheadRoutineNesting--;
            if ($reachedScanCode$ && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true;
            }
        }
        passedPredicate = false;
        return true;
    }

    // scanahead routine for expansion at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1163:5
    // BuildScanRoutine macro
    private final boolean check$Grammer_ccc$1163$5$(boolean scanToEnd) {
        boolean $reachedScanCode$ = false;
        int passedPredicateThreshold = remainingLookahead - 1;
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            $reachedScanCode$ = true;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1163:5
            if (!scanToken(PLUS)) return false;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1163:14
            // NonTerminal parseTerm at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1163:14
            pushOntoLookaheadStack("parseTerm2", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1163, 14);
            currentLookaheadProduction = "parseTerm";
            try {
                if (!check$parseTerm(true)) return false;
            } finally {
                popLookaheadStack();
            }
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1164:5
        } finally {
            lookaheadRoutineNesting--;
            if ($reachedScanCode$ && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true;
            }
        }
        passedPredicate = false;
        return true;
    }

    // scanahead routine for expansion at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1170:5
    // BuildScanRoutine macro
    private final boolean check$Grammer_ccc$1170$5(boolean scanToEnd) {
        boolean $reachedScanCode$ = false;
        int passedPredicateThreshold = remainingLookahead - 1;
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            $reachedScanCode$ = true;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1170:5
            if (!scanToken(MINUS)) return false;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1170:15
            // NonTerminal parseTerm at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1170:15
            pushOntoLookaheadStack("parseTerm2", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1170, 15);
            currentLookaheadProduction = "parseTerm";
            try {
                if (!check$parseTerm(true)) return false;
            } finally {
                popLookaheadStack();
            }
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1171:5
        } finally {
            lookaheadRoutineNesting--;
            if ($reachedScanCode$ && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true;
            }
        }
        passedPredicate = false;
        return true;
    }

    // scanahead routine for expansion at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1177:5
    // BuildScanRoutine macro
    private final boolean check$Grammer_ccc$1177$5(boolean scanToEnd) {
        boolean $reachedScanCode$ = false;
        int passedPredicateThreshold = remainingLookahead - 1;
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            $reachedScanCode$ = true;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1177:5
            if (!scanToken(CONCAT)) return false;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1177:16
            // NonTerminal parseTerm at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1177:16
            pushOntoLookaheadStack("parseTerm2", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1177, 16);
            currentLookaheadProduction = "parseTerm";
            try {
                if (!check$parseTerm(true)) return false;
            } finally {
                popLookaheadStack();
            }
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1178:5
        } finally {
            lookaheadRoutineNesting--;
            if ($reachedScanCode$ && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true;
            }
        }
        passedPredicate = false;
        return true;
    }

    // scanahead routine for expansion at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1197:5
    // BuildScanRoutine macro
    private final boolean check$Grammer_ccc$1197$5(boolean scanToEnd) {
        boolean $reachedScanCode$ = false;
        int passedPredicateThreshold = remainingLookahead - 1;
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            $reachedScanCode$ = true;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for ExpansionChoice specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1197:5
            Token token2518 = currentLookaheadToken;
            int remainingLookahead2518 = remainingLookahead;
            boolean hitFailure2518 = hitFailure, passedPredicate2518 = passedPredicate;
            try {
                passedPredicate = false;
                if (!check$Grammer_ccc$1197$5$(false)) {
                    currentLookaheadToken = token2518;
                    remainingLookahead = remainingLookahead2518;
                    hitFailure = hitFailure2518;
                    if (passedPredicate && !legacyGlitchyLookahead) return false;
                    passedPredicate = false;
                    if (!check$Grammer_ccc$1204$5(false)) {
                        currentLookaheadToken = token2518;
                        remainingLookahead = remainingLookahead2518;
                        hitFailure = hitFailure2518;
                        return false;
                    }
                }
            } finally {
                passedPredicate = passedPredicate2518;
            }
        } finally {
            lookaheadRoutineNesting--;
            if ($reachedScanCode$ && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true;
            }
        }
        passedPredicate = false;
        return true;
    }

    // scanahead routine for expansion at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1197:5
    // BuildScanRoutine macro
    private final boolean check$Grammer_ccc$1197$5$(boolean scanToEnd) {
        boolean $reachedScanCode$ = false;
        int passedPredicateThreshold = remainingLookahead - 1;
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            $reachedScanCode$ = true;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1197:5
            if (!scanToken(ASTERISK)) return false;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1197:18
            // NonTerminal parseFactor at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1197:18
            pushOntoLookaheadStack("parseTerm", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1197, 18);
            currentLookaheadProduction = "parseFactor";
            try {
                if (!check$parseFactor(true)) return false;
            } finally {
                popLookaheadStack();
            }
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1198:5
        } finally {
            lookaheadRoutineNesting--;
            if ($reachedScanCode$ && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true;
            }
        }
        passedPredicate = false;
        return true;
    }

    // scanahead routine for expansion at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1204:5
    // BuildScanRoutine macro
    private final boolean check$Grammer_ccc$1204$5(boolean scanToEnd) {
        boolean $reachedScanCode$ = false;
        int passedPredicateThreshold = remainingLookahead - 1;
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            $reachedScanCode$ = true;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1204:5
            if (!scanToken(SOLIDUS)) return false;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1204:17
            // NonTerminal parseFactor at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1204:17
            pushOntoLookaheadStack("parseTerm", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1204, 17);
            currentLookaheadProduction = "parseFactor";
            try {
                if (!check$parseFactor(true)) return false;
            } finally {
                popLookaheadStack();
            }
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1205:5
        } finally {
            lookaheadRoutineNesting--;
            if ($reachedScanCode$ && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true;
            }
        }
        passedPredicate = false;
        return true;
    }

    // scanahead routine for expansion at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1222:3
    // BuildScanRoutine macro
    private final boolean check$Grammer_ccc$1222$3(boolean scanToEnd) {
        boolean $reachedScanCode$ = false;
        int passedPredicateThreshold = remainingLookahead - 1;
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            $reachedScanCode$ = true;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1222:3
            // NonTerminal parsePrimary at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1222:3
            pushOntoLookaheadStack("parseFactor", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1222, 3);
            currentLookaheadProduction = "parsePrimary";
            try {
                if (!check$parsePrimary(false)) return false;
            } finally {
                popLookaheadStack();
            }
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1223:3
        } finally {
            lookaheadRoutineNesting--;
            if ($reachedScanCode$ && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true;
            }
        }
        passedPredicate = false;
        return true;
    }

    // scanahead routine for expansion at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1226:3
    // BuildScanRoutine macro
    private final boolean check$Grammer_ccc$1226$3(boolean scanToEnd) {
        boolean $reachedScanCode$ = false;
        int passedPredicateThreshold = remainingLookahead - 1;
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            $reachedScanCode$ = true;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1226:3
            if (!scanToken(PLUS)) return false;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1226:12
            // NonTerminal parsePrimary at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1226:12
            pushOntoLookaheadStack("parseFactor", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1226, 12);
            currentLookaheadProduction = "parsePrimary";
            try {
                if (!check$parsePrimary(true)) return false;
            } finally {
                popLookaheadStack();
            }
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1227:3
        } finally {
            lookaheadRoutineNesting--;
            if ($reachedScanCode$ && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true;
            }
        }
        passedPredicate = false;
        return true;
    }

    // scanahead routine for expansion at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1230:3
    // BuildScanRoutine macro
    private final boolean check$Grammer_ccc$1230$3(boolean scanToEnd) {
        boolean $reachedScanCode$ = false;
        int passedPredicateThreshold = remainingLookahead - 1;
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            $reachedScanCode$ = true;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1230:3
            if (!scanToken(MINUS)) return false;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1230:13
            // NonTerminal parsePrimary at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1230:13
            pushOntoLookaheadStack("parseFactor", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1230, 13);
            currentLookaheadProduction = "parsePrimary";
            try {
                if (!check$parsePrimary(true)) return false;
            } finally {
                popLookaheadStack();
            }
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1231:3
        } finally {
            lookaheadRoutineNesting--;
            if ($reachedScanCode$ && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true;
            }
        }
        passedPredicate = false;
        return true;
    }

    // scanahead routine for expansion at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1237:3
    // BuildScanRoutine macro
    private final boolean check$Grammer_ccc$1237$3(boolean scanToEnd) {
        boolean $reachedScanCode$ = false;
        int passedPredicateThreshold = remainingLookahead - 1;
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            $reachedScanCode$ = true;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1237:3
            if (!scanToken(EXISTING)) return false;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1237:16
            // NonTerminal parsePrimary at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1237:16
            pushOntoLookaheadStack("parseFactor", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1237, 16);
            currentLookaheadProduction = "parsePrimary";
            try {
                if (!check$parsePrimary(true)) return false;
            } finally {
                popLookaheadStack();
            }
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1238:3
        } finally {
            lookaheadRoutineNesting--;
            if ($reachedScanCode$ && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true;
            }
        }
        passedPredicate = false;
        return true;
    }

    // scanahead routine for expansion at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1253:5
    // BuildScanRoutine macro
    private final boolean check$Grammer_ccc$1253$5(boolean scanToEnd) {
        boolean $reachedScanCode$ = false;
        int passedPredicateThreshold = remainingLookahead - 1;
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            $reachedScanCode$ = true;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1253:5
            if (!scanToken(DOT)) return false;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1253:13
            // NonTerminal objectIdentifierOrFuncall at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1253:13
            pushOntoLookaheadStack("parsePrimary", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1253, 13);
            currentLookaheadProduction = "objectIdentifierOrFuncall";
            try {
                if (!check$objectIdentifierOrFuncall(true)) return false;
            } finally {
                popLookaheadStack();
            }
        } finally {
            lookaheadRoutineNesting--;
            if ($reachedScanCode$ && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true;
            }
        }
        passedPredicate = false;
        return true;
    }

    // scanahead routine for expansion at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1268:5
    // BuildScanRoutine macro
    private final boolean check$Grammer_ccc$1268$5(boolean scanToEnd) {
        boolean $reachedScanCode$ = false;
        int passedPredicateThreshold = remainingLookahead - 1;
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            $reachedScanCode$ = true;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1268:5
            if (!scanToken(LPAREN)) return false;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1270:7
            // NonTerminal expOrEmptyList at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1270:7
            pushOntoLookaheadStack("objectIdentifierOrFuncall", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1270, 7);
            currentLookaheadProduction = "expOrEmptyList";
            try {
                if (!check$expOrEmptyList(true)) return false;
            } finally {
                popLookaheadStack();
            }
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1272:5
            if (!scanToken(RPAREN)) return false;
        } finally {
            lookaheadRoutineNesting--;
            if ($reachedScanCode$ && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true;
            }
        }
        passedPredicate = false;
        return true;
    }

    // scanahead routine for expansion at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1318:3
    // BuildScanRoutine macro
    private final boolean check$Grammer_ccc$1318$3(boolean scanToEnd) {
        boolean $reachedScanCode$ = false;
        int passedPredicateThreshold = remainingLookahead - 1;
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            $reachedScanCode$ = true;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1318:3
            if (!scanToken(CAST)) return false;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1318:12
            if (!scanToken(LPAREN)) return false;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1318:23
            // NonTerminal parseUnaliasedExpression at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1318:23
            pushOntoLookaheadStack("parseAtom", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1318, 23);
            currentLookaheadProduction = "parseUnaliasedExpression";
            try {
                if (!check$parseUnaliasedExpression(true)) return false;
            } finally {
                popLookaheadStack();
            }
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1319:3
            if (!scanToken(AS)) return false;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1319:10
            // NonTerminal parseNameObjectIdentifier at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1319:10
            pushOntoLookaheadStack("parseAtom", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1319, 10);
            currentLookaheadProduction = "parseNameObjectIdentifier";
            try {
                if (!check$parseNameObjectIdentifier(true)) return false;
            } finally {
                popLookaheadStack();
            }
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1319:59
            if (!scanToken(RPAREN)) return false;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1320:3
        } finally {
            lookaheadRoutineNesting--;
            if ($reachedScanCode$ && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true;
            }
        }
        passedPredicate = false;
        return true;
    }

    // scanahead routine for expansion at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1328:3
    // BuildScanRoutine macro
    private final boolean check$Grammer_ccc$1328$3(boolean scanToEnd) {
        boolean $reachedScanCode$ = false;
        int passedPredicateThreshold = remainingLookahead - 1;
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            $reachedScanCode$ = true;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1328:3
            if (!scanToken(LPAREN)) return false;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1328:14
            // NonTerminal expList at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1328:14
            pushOntoLookaheadStack("parseAtom", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1328, 14);
            currentLookaheadProduction = "expList";
            try {
                if (!check$expList(true)) return false;
            } finally {
                popLookaheadStack();
            }
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1328:36
            if (!scanToken(RPAREN)) return false;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1329:3
        } finally {
            lookaheadRoutineNesting--;
            if ($reachedScanCode$ && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true;
            }
        }
        passedPredicate = false;
        return true;
    }

    // scanahead routine for expansion at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1337:3
    // BuildScanRoutine macro
    private final boolean check$Grammer_ccc$1337$3(boolean scanToEnd) {
        boolean $reachedScanCode$ = false;
        int passedPredicateThreshold = remainingLookahead - 1;
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            $reachedScanCode$ = true;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1337:3
            if (!scanToken(LBRACE)) return false;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for ExpansionChoice specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1339:5
            Token token2568 = currentLookaheadToken;
            int remainingLookahead2568 = remainingLookahead;
            boolean hitFailure2568 = hitFailure, passedPredicate2568 = passedPredicate;
            try {
                passedPredicate = false;
                if (!check$Grammer_ccc$1339$5(false)) {
                    currentLookaheadToken = token2568;
                    remainingLookahead = remainingLookahead2568;
                    hitFailure = hitFailure2568;
                    if (passedPredicate && !legacyGlitchyLookahead) return false;
                    passedPredicate = false;
                    if (!check$Grammer_ccc$1344$5(false)) {
                        currentLookaheadToken = token2568;
                        remainingLookahead = remainingLookahead2568;
                        hitFailure = hitFailure2568;
                        return false;
                    }
                }
            } finally {
                passedPredicate = passedPredicate2568;
            }
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1346:3
            if (!scanToken(RBRACE)) return false;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1347:3
        } finally {
            lookaheadRoutineNesting--;
            if ($reachedScanCode$ && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true;
            }
        }
        passedPredicate = false;
        return true;
    }

    // scanahead routine for expansion at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1339:5
    // BuildScanRoutine macro
    private final boolean check$Grammer_ccc$1339$5(boolean scanToEnd) {
        boolean $reachedScanCode$ = false;
        int passedPredicateThreshold = remainingLookahead - 2147483647;
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead <= 0) {
                passedPredicate = true;
                return !hitFailure;
            }
            if (!check$Grammer_ccc$1339$10(true)) return false;
            // End BuildPredicateCode macro
            $reachedScanCode$ = true;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1340:5
        } finally {
            lookaheadRoutineNesting--;
            if ($reachedScanCode$ && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true;
            }
        }
        passedPredicate = false;
        return true;
    }

    // scanahead routine for expansion at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1344:5
    // BuildScanRoutine macro
    private final boolean check$Grammer_ccc$1344$5(boolean scanToEnd) {
        boolean $reachedScanCode$ = false;
        int passedPredicateThreshold = remainingLookahead - 1;
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            $reachedScanCode$ = true;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1344:5
            // NonTerminal expList at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1344:5
            pushOntoLookaheadStack("parseAtom", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1344, 5);
            currentLookaheadProduction = "expList";
            try {
                if (!check$expList(false)) return false;
            } finally {
                popLookaheadStack();
            }
        } finally {
            lookaheadRoutineNesting--;
            if ($reachedScanCode$ && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true;
            }
        }
        passedPredicate = false;
        return true;
    }

    // scanahead routine for expansion at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1351:3
    // BuildScanRoutine macro
    private final boolean check$Grammer_ccc$1351$3(boolean scanToEnd) {
        boolean $reachedScanCode$ = false;
        int passedPredicateThreshold = remainingLookahead - 1;
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            $reachedScanCode$ = true;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1351:3
            // NonTerminal parseCaseExpression at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1351:3
            pushOntoLookaheadStack("parseAtom", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1351, 3);
            currentLookaheadProduction = "parseCaseExpression";
            try {
                if (!check$parseCaseExpression(false)) return false;
            } finally {
                popLookaheadStack();
            }
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1352:3
        } finally {
            lookaheadRoutineNesting--;
            if ($reachedScanCode$ && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true;
            }
        }
        passedPredicate = false;
        return true;
    }

    // scanahead routine for expansion at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1358:3
    // BuildScanRoutine macro
    private final boolean check$Grammer_ccc$1358$3(boolean scanToEnd) {
        boolean $reachedScanCode$ = false;
        int passedPredicateThreshold = remainingLookahead - 1;
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            $reachedScanCode$ = true;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1358:3
            // NonTerminal parseNameObjectIdentifier at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1358:3
            pushOntoLookaheadStack("parseAtom", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1358, 3);
            currentLookaheadProduction = "parseNameObjectIdentifier";
            try {
                if (!check$parseNameObjectIdentifier(false)) return false;
            } finally {
                popLookaheadStack();
            }
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for ZeroOrMore specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1359:3
            boolean passedPredicate2581 = passedPredicate;
            try {
                while (remainingLookahead > 0 && !hitFailure) {
                    Token token2582 = currentLookaheadToken;
                    passedPredicate = false;
                    if (!check$Grammer_ccc$1360$5(false)) {
                        if (passedPredicate && !legacyGlitchyLookahead) return false;
                        currentLookaheadToken = token2582;
                        break;
                    }
                }
            } finally {
                passedPredicate = passedPredicate2581;
            }
            hitFailure = false;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for ExpansionChoice specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1369:5
            Token token2585 = currentLookaheadToken;
            int remainingLookahead2585 = remainingLookahead;
            boolean hitFailure2585 = hitFailure, passedPredicate2585 = passedPredicate;
            try {
                passedPredicate = false;
                if (!check$Grammer_ccc$1369$5(false)) {
                    currentLookaheadToken = token2585;
                    remainingLookahead = remainingLookahead2585;
                    hitFailure = hitFailure2585;
                    if (passedPredicate && !legacyGlitchyLookahead) return false;
                    passedPredicate = false;
                    if (!check$Grammer_ccc$1380$16(false)) {
                        currentLookaheadToken = token2585;
                        remainingLookahead = remainingLookahead2585;
                        hitFailure = hitFailure2585;
                        return false;
                    }
                }
            } finally {
                passedPredicate = passedPredicate2585;
            }
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1384:3
        } finally {
            lookaheadRoutineNesting--;
            if ($reachedScanCode$ && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true;
            }
        }
        passedPredicate = false;
        return true;
    }

    // scanahead routine for expansion at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1360:5
    // BuildScanRoutine macro
    private final boolean check$Grammer_ccc$1360$5(boolean scanToEnd) {
        boolean $reachedScanCode$ = false;
        int passedPredicateThreshold = remainingLookahead - 1;
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            $reachedScanCode$ = true;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1360:5
            if (!scanToken(BANG)) return false;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1360:14
            // NonTerminal parseNameObjectIdentifier at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1360:14
            pushOntoLookaheadStack("parseAtom", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1360, 14);
            currentLookaheadProduction = "parseNameObjectIdentifier";
            try {
                if (!check$parseNameObjectIdentifier(true)) return false;
            } finally {
                popLookaheadStack();
            }
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1361:5
        } finally {
            lookaheadRoutineNesting--;
            if ($reachedScanCode$ && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true;
            }
        }
        passedPredicate = false;
        return true;
    }

    // scanahead routine for expansion at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1369:5
    // BuildScanRoutine macro
    private final boolean check$Grammer_ccc$1369$5(boolean scanToEnd) {
        boolean $reachedScanCode$ = false;
        int passedPredicateThreshold = remainingLookahead - 1;
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            $reachedScanCode$ = true;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1369:5
            if (!scanToken(LPAREN)) return false;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for ExpansionChoice specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1371:7
            Token token2595 = currentLookaheadToken;
            int remainingLookahead2595 = remainingLookahead;
            boolean hitFailure2595 = hitFailure, passedPredicate2595 = passedPredicate;
            try {
                passedPredicate = false;
                if (!check$Grammer_ccc$1371$7(false)) {
                    currentLookaheadToken = token2595;
                    remainingLookahead = remainingLookahead2595;
                    hitFailure = hitFailure2595;
                    if (passedPredicate && !legacyGlitchyLookahead) return false;
                    passedPredicate = false;
                    if (!check$Grammer_ccc$1376$7(false)) {
                        currentLookaheadToken = token2595;
                        remainingLookahead = remainingLookahead2595;
                        hitFailure = hitFailure2595;
                        return false;
                    }
                }
            } finally {
                passedPredicate = passedPredicate2595;
            }
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1378:5
            if (!scanToken(RPAREN)) return false;
        } finally {
            lookaheadRoutineNesting--;
            if ($reachedScanCode$ && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true;
            }
        }
        passedPredicate = false;
        return true;
    }

    // scanahead routine for expansion at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1371:7
    // BuildScanRoutine macro
    private final boolean check$Grammer_ccc$1371$7(boolean scanToEnd) {
        boolean $reachedScanCode$ = false;
        int passedPredicateThreshold = remainingLookahead - 2147483647;
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            if (remainingLookahead <= 0) {
                passedPredicate = true;
                return !hitFailure;
            }
            if (!check$Grammer_ccc$1371$12(true)) return false;
            // End BuildPredicateCode macro
            $reachedScanCode$ = true;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1372:7
        } finally {
            lookaheadRoutineNesting--;
            if ($reachedScanCode$ && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true;
            }
        }
        passedPredicate = false;
        return true;
    }

    // scanahead routine for expansion at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1376:7
    // BuildScanRoutine macro
    private final boolean check$Grammer_ccc$1376$7(boolean scanToEnd) {
        boolean $reachedScanCode$ = false;
        int passedPredicateThreshold = remainingLookahead - 1;
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            $reachedScanCode$ = true;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1376:7
            // NonTerminal expOrEmptyList at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1376:7
            pushOntoLookaheadStack("parseAtom", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1376, 7);
            currentLookaheadProduction = "expOrEmptyList";
            try {
                if (!check$expOrEmptyList(true)) return false;
            } finally {
                popLookaheadStack();
            }
        } finally {
            lookaheadRoutineNesting--;
            if ($reachedScanCode$ && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true;
            }
        }
        passedPredicate = false;
        return true;
    }

    // scanahead routine for expansion at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1380:16
    // BuildScanRoutine macro
    private final boolean check$Grammer_ccc$1380$16(boolean scanToEnd) {
        boolean $reachedScanCode$ = false;
        int passedPredicateThreshold = remainingLookahead - 1;
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            $reachedScanCode$ = true;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1380:16
        } finally {
            lookaheadRoutineNesting--;
            if ($reachedScanCode$ && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true;
            }
        }
        passedPredicate = false;
        return true;
    }

    // scanahead routine for expansion at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1398:5
    // BuildScanRoutine macro
    private final boolean check$Grammer_ccc$1398$5(boolean scanToEnd) {
        boolean $reachedScanCode$ = false;
        int passedPredicateThreshold = remainingLookahead - 1;
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            $reachedScanCode$ = true;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1398:5
            // NonTerminal parseExpression at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1398:5
            pushOntoLookaheadStack("parseCaseExpression", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1398, 5);
            currentLookaheadProduction = "parseExpression";
            try {
                if (!check$parseExpression(false)) return false;
            } finally {
                popLookaheadStack();
            }
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1399:5
        } finally {
            lookaheadRoutineNesting--;
            if ($reachedScanCode$ && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true;
            }
        }
        passedPredicate = false;
        return true;
    }

    // scanahead routine for expansion at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1405:5
    // BuildScanRoutine macro
    private final boolean check$Grammer_ccc$1405$5(boolean scanToEnd) {
        boolean $reachedScanCode$ = false;
        int passedPredicateThreshold = remainingLookahead - 1;
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            $reachedScanCode$ = true;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1405:5
            if (!scanToken(WHEN)) return false;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1405:14
            // NonTerminal parseExpression at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1405:14
            pushOntoLookaheadStack("parseCaseExpression", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1405, 14);
            currentLookaheadProduction = "parseExpression";
            try {
                if (!check$parseExpression(true)) return false;
            } finally {
                popLookaheadStack();
            }
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1405:43
            if (!scanToken(THEN)) return false;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1405:52
            // NonTerminal parseExpression at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1405:52
            pushOntoLookaheadStack("parseCaseExpression", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1405, 52);
            currentLookaheadProduction = "parseExpression";
            try {
                if (!check$parseExpression(true)) return false;
            } finally {
                popLookaheadStack();
            }
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1406:5
        } finally {
            lookaheadRoutineNesting--;
            if ($reachedScanCode$ && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true;
            }
        }
        passedPredicate = false;
        return true;
    }

    // scanahead routine for expansion at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1412:5
    // BuildScanRoutine macro
    private final boolean check$Grammer_ccc$1412$5(boolean scanToEnd) {
        boolean $reachedScanCode$ = false;
        int passedPredicateThreshold = remainingLookahead - 1;
        try {
            lookaheadRoutineNesting++;
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            $reachedScanCode$ = true;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1412:5
            if (!scanToken(ELSE)) return false;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1412:14
            // NonTerminal parseExpression at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1412:14
            pushOntoLookaheadStack("parseCaseExpression", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1412, 14);
            currentLookaheadProduction = "parseExpression";
            try {
                if (!check$parseExpression(true)) return false;
            } finally {
                popLookaheadStack();
            }
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1413:5
        } finally {
            lookaheadRoutineNesting--;
            if ($reachedScanCode$ && remainingLookahead <= passedPredicateThreshold) {
                passedPredicate = true;
            }
        }
        passedPredicate = false;
        return true;
    }

    // BuildPredicateRoutine: expansion at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:956:5
    private final boolean scan$Grammer_ccc$956$5() {
        remainingLookahead = UNLIMITED;
        currentLookaheadToken = lastConsumedToken;
        final boolean scanToEnd = false;
        try {
            // BuildPredicateCode macro
            if (remainingLookahead <= 0) {
                passedPredicate = true;
                return !hitFailure;
            }
            if (!check$Grammer_ccc$956$10(true)) return false;
            // End BuildPredicateCode macro
            return true;
        } finally {
            lookaheadRoutineNesting = 0;
            currentLookaheadToken = null;
            hitFailure = false;
        }
    }

    // BuildPredicateRoutine: expansion at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1088:5
    private final boolean scan$Grammer_ccc$1088$5() {
        remainingLookahead = 2;
        currentLookaheadToken = lastConsumedToken;
        final boolean scanToEnd = false;
        try {
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1089:5
            if (!scanToken(IS)) return false;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1089:12
            if (!scanToken(NULL)) return false;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1090:5
            return true;
        } finally {
            lookaheadRoutineNesting = 0;
            currentLookaheadToken = null;
            hitFailure = false;
        }
    }

    // BuildPredicateRoutine: expansion at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1098:5
    private final boolean scan$Grammer_ccc$1098$5() {
        remainingLookahead = 2;
        currentLookaheadToken = lastConsumedToken;
        final boolean scanToEnd = false;
        try {
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1099:5
            if (!scanToken(IS)) return false;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1099:12
            // NonTerminal parseTerm2 at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1099:12
            pushOntoLookaheadStack("parseTerm3", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1099, 12);
            currentLookaheadProduction = "parseTerm2";
            try {
                if (!check$parseTerm2(true)) return false;
            } finally {
                popLookaheadStack();
            }
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1100:5
            return true;
        } finally {
            lookaheadRoutineNesting = 0;
            currentLookaheadToken = null;
            hitFailure = false;
        }
    }

    // BuildPredicateRoutine: expansion at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1118:5
    private final boolean scan$Grammer_ccc$1118$5() {
        remainingLookahead = 2;
        currentLookaheadToken = lastConsumedToken;
        final boolean scanToEnd = false;
        try {
            // BuildPredicateCode macro
            // End BuildPredicateCode macro
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1119:5
            if (!scanToken(NOT)) return false;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1119:13
            if (!scanToken(MATCHES)) return false;
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1119:25
            // NonTerminal parseTerm2 at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1119:25
            pushOntoLookaheadStack("parseTerm3", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1119, 25);
            currentLookaheadProduction = "parseTerm2";
            try {
                if (!check$parseTerm2(true)) return false;
            } finally {
                popLookaheadStack();
            }
            if (hitFailure) return false;
            if (remainingLookahead <= 0) {
                return true;
            }
            // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1120:5
            return true;
        } finally {
            lookaheadRoutineNesting = 0;
            currentLookaheadToken = null;
            hitFailure = false;
        }
    }

    // BuildPredicateRoutine: expansion at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1339:5
    private final boolean scan$Grammer_ccc$1339$5() {
        remainingLookahead = UNLIMITED;
        currentLookaheadToken = lastConsumedToken;
        final boolean scanToEnd = false;
        try {
            // BuildPredicateCode macro
            if (remainingLookahead <= 0) {
                passedPredicate = true;
                return !hitFailure;
            }
            if (!check$Grammer_ccc$1339$10(true)) return false;
            // End BuildPredicateCode macro
            return true;
        } finally {
            lookaheadRoutineNesting = 0;
            currentLookaheadToken = null;
            hitFailure = false;
        }
    }

    // BuildPredicateRoutine: expansion at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1371:7
    private final boolean scan$Grammer_ccc$1371$7() {
        remainingLookahead = UNLIMITED;
        currentLookaheadToken = lastConsumedToken;
        final boolean scanToEnd = false;
        try {
            // BuildPredicateCode macro
            if (remainingLookahead <= 0) {
                passedPredicate = true;
                return !hitFailure;
            }
            if (!check$Grammer_ccc$1371$12(true)) return false;
            // End BuildPredicateCode macro
            return true;
        } finally {
            lookaheadRoutineNesting = 0;
            currentLookaheadToken = null;
            hitFailure = false;
        }
    }

    // lookahead routine for lookahead at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:956:5
    private final boolean check$Grammer_ccc$956$10(boolean scanToEnd) {
        int prevRemainingLookahead = remainingLookahead;
        boolean prevHitFailure = hitFailure;
        Token prevScanAheadToken = currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            if (!scanToken(DOT)) return false;
            return !hitFailure;
        } finally {
            lookaheadRoutineNesting--;
            currentLookaheadToken = prevScanAheadToken;
            remainingLookahead = prevRemainingLookahead;
            hitFailure = prevHitFailure;
        }
    }

    // lookahead routine for lookahead at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1339:5
    private final boolean check$Grammer_ccc$1339$10(boolean scanToEnd) {
        int prevRemainingLookahead = remainingLookahead;
        boolean prevHitFailure = hitFailure;
        Token prevScanAheadToken = currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            if (!scanToken(RBRACE)) return false;
            return !hitFailure;
        } finally {
            lookaheadRoutineNesting--;
            currentLookaheadToken = prevScanAheadToken;
            remainingLookahead = prevRemainingLookahead;
            hitFailure = prevHitFailure;
        }
    }

    // lookahead routine for lookahead at:
    // /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1371:7
    private final boolean check$Grammer_ccc$1371$12(boolean scanToEnd) {
        int prevRemainingLookahead = remainingLookahead;
        boolean prevHitFailure = hitFailure;
        Token prevScanAheadToken = currentLookaheadToken;
        try {
            lookaheadRoutineNesting++;
            if (!scanToken(RPAREN)) return false;
            return !hitFailure;
        } finally {
            lookaheadRoutineNesting--;
            currentLookaheadToken = prevScanAheadToken;
            remainingLookahead = prevRemainingLookahead;
            hitFailure = prevHitFailure;
        }
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$parseExpression(boolean scanToEnd) {
        if (hitFailure) return false;
        if (remainingLookahead <= 0) {
            return true;
        }
        // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:766:3
        // NonTerminal parseUnaliasedExpression at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:766:3
        pushOntoLookaheadStack("parseExpression", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 766, 3);
        currentLookaheadProduction = "parseUnaliasedExpression";
        try {
            if (!check$parseUnaliasedExpression(false)) return false;
        } finally {
            popLookaheadStack();
        }
        if (hitFailure) return false;
        if (remainingLookahead <= 0) {
            return true;
        }
        // Lookahead Code for ZeroOrMore specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:767:3
        boolean passedPredicate2784 = passedPredicate;
        try {
            while (remainingLookahead > 0 && !hitFailure) {
                Token token2785 = currentLookaheadToken;
                passedPredicate = false;
                if (!check$Grammer_ccc$768$5(false)) {
                    if (passedPredicate && !legacyGlitchyLookahead) return false;
                    currentLookaheadToken = token2785;
                    break;
                }
            }
        } finally {
            passedPredicate = passedPredicate2784;
        }
        hitFailure = false;
        if (hitFailure) return false;
        if (remainingLookahead <= 0) {
            return true;
        }
        // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:777:3
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$parseExpressionOrEmpty(boolean scanToEnd) {
        if (hitFailure) return false;
        if (remainingLookahead <= 0) {
            return true;
        }
        // Lookahead Code for ExpansionChoice specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:787:3
        Token token2788 = currentLookaheadToken;
        int remainingLookahead2788 = remainingLookahead;
        boolean hitFailure2788 = hitFailure, passedPredicate2788 = passedPredicate;
        try {
            passedPredicate = false;
            if (!check$Grammer_ccc$787$3(false)) {
                currentLookaheadToken = token2788;
                remainingLookahead = remainingLookahead2788;
                hitFailure = hitFailure2788;
                if (passedPredicate && !legacyGlitchyLookahead) return false;
                passedPredicate = false;
                if (!check$Grammer_ccc$792$3(false)) {
                    currentLookaheadToken = token2788;
                    remainingLookahead = remainingLookahead2788;
                    hitFailure = hitFailure2788;
                    return false;
                }
            }
        } finally {
            passedPredicate = passedPredicate2788;
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$expOrEmptyList(boolean scanToEnd) {
        if (hitFailure) return false;
        if (remainingLookahead <= 0) {
            return true;
        }
        // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:806:3
        // NonTerminal parseExpressionOrEmpty at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:806:3
        pushOntoLookaheadStack("expOrEmptyList", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 806, 3);
        currentLookaheadProduction = "parseExpressionOrEmpty";
        try {
            if (!check$parseExpressionOrEmpty(true)) return false;
        } finally {
            popLookaheadStack();
        }
        if (hitFailure) return false;
        if (remainingLookahead <= 0) {
            return true;
        }
        // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:807:3
        if (hitFailure) return false;
        if (remainingLookahead <= 0) {
            return true;
        }
        // Lookahead Code for ZeroOrMore specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:810:3
        boolean passedPredicate2793 = passedPredicate;
        try {
            while (remainingLookahead > 0 && !hitFailure) {
                Token token2794 = currentLookaheadToken;
                passedPredicate = false;
                if (!check$Grammer_ccc$811$5(false)) {
                    if (passedPredicate && !legacyGlitchyLookahead) return false;
                    currentLookaheadToken = token2794;
                    break;
                }
            }
        } finally {
            passedPredicate = passedPredicate2793;
        }
        hitFailure = false;
        if (hitFailure) return false;
        if (remainingLookahead <= 0) {
            return true;
        }
        // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:817:3
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$expList(boolean scanToEnd) {
        if (hitFailure) return false;
        if (remainingLookahead <= 0) {
            return true;
        }
        // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:829:3
        // NonTerminal parseExpression at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:829:3
        pushOntoLookaheadStack("expList", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 829, 3);
        currentLookaheadProduction = "parseExpression";
        try {
            if (!check$parseExpression(false)) return false;
        } finally {
            popLookaheadStack();
        }
        if (hitFailure) return false;
        if (remainingLookahead <= 0) {
            return true;
        }
        // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:830:3
        if (hitFailure) return false;
        if (remainingLookahead <= 0) {
            return true;
        }
        // Lookahead Code for ZeroOrMore specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:833:3
        boolean passedPredicate2800 = passedPredicate;
        try {
            while (remainingLookahead > 0 && !hitFailure) {
                Token token2801 = currentLookaheadToken;
                passedPredicate = false;
                if (!check$Grammer_ccc$834$5(false)) {
                    if (passedPredicate && !legacyGlitchyLookahead) return false;
                    currentLookaheadToken = token2801;
                    break;
                }
            }
        } finally {
            passedPredicate = passedPredicate2800;
        }
        hitFailure = false;
        if (hitFailure) return false;
        if (remainingLookahead <= 0) {
            return true;
        }
        // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:840:3
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$parseIdentifier(boolean scanToEnd) {
        if (hitFailure) return false;
        if (remainingLookahead <= 0) {
            return true;
        }
        // Lookahead Code for ExpansionChoice specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:862:5
        Token token2810 = currentLookaheadToken;
        int remainingLookahead2810 = remainingLookahead;
        boolean hitFailure2810 = hitFailure, passedPredicate2810 = passedPredicate;
        try {
            passedPredicate = false;
            if (!check$Grammer_ccc$862$5$(false)) {
                currentLookaheadToken = token2810;
                remainingLookahead = remainingLookahead2810;
                hitFailure = hitFailure2810;
                if (passedPredicate && !legacyGlitchyLookahead) return false;
                passedPredicate = false;
                if (!check$Grammer_ccc$864$5(false)) {
                    currentLookaheadToken = token2810;
                    remainingLookahead = remainingLookahead2810;
                    hitFailure = hitFailure2810;
                    return false;
                }
            }
        } finally {
            passedPredicate = passedPredicate2810;
        }
        if (hitFailure) return false;
        if (remainingLookahead <= 0) {
            return true;
        }
        // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:866:3
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$parseNameObjectIdentifier(boolean scanToEnd) {
        if (hitFailure) return false;
        if (remainingLookahead <= 0) {
            return true;
        }
        // Lookahead Code for ExpansionChoice specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:876:3
        Token token2813 = currentLookaheadToken;
        int remainingLookahead2813 = remainingLookahead;
        boolean hitFailure2813 = hitFailure, passedPredicate2813 = passedPredicate;
        try {
            passedPredicate = false;
            if (!scanToken(DIMENSION, PROPERTIES)) {
                currentLookaheadToken = token2813;
                remainingLookahead = remainingLookahead2813;
                hitFailure = hitFailure2813;
                if (passedPredicate && !legacyGlitchyLookahead) return false;
                passedPredicate = false;
                if (!scanToken(ID)) {
                    currentLookaheadToken = token2813;
                    remainingLookahead = remainingLookahead2813;
                    hitFailure = hitFailure2813;
                    if (passedPredicate && !legacyGlitchyLookahead) return false;
                    passedPredicate = false;
                    if (!check$Grammer_ccc$885$3(false)) {
                        currentLookaheadToken = token2813;
                        remainingLookahead = remainingLookahead2813;
                        hitFailure = hitFailure2813;
                        if (passedPredicate && !legacyGlitchyLookahead) return false;
                        passedPredicate = false;
                        if (!scanToken(QUOTED_ID)) {
                            currentLookaheadToken = token2813;
                            remainingLookahead = remainingLookahead2813;
                            hitFailure = hitFailure2813;
                            return false;
                        }
                    }
                }
            }
        } finally {
            passedPredicate = passedPredicate2813;
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$parseKeyIdentifier(boolean scanToEnd) {
        if (hitFailure) return false;
        if (remainingLookahead <= 0) {
            return true;
        }
        // Lookahead Code for OneOrMore specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:904:3
        if (!scanToken(AMP_QUOTED_ID, AMP_UNQUOTED_ID)) return false;
        boolean passedPredicate2817 = passedPredicate;
        try {
            while (remainingLookahead > 0 && !hitFailure) {
                Token token2818 = currentLookaheadToken;
                passedPredicate = false;
                if (!scanToken(AMP_QUOTED_ID, AMP_UNQUOTED_ID)) {
                    if (passedPredicate && !legacyGlitchyLookahead) return false;
                    currentLookaheadToken = token2818;
                    break;
                }
            }
        } finally {
            passedPredicate = passedPredicate2817;
        }
        hitFailure = false;
        if (hitFailure) return false;
        if (remainingLookahead <= 0) {
            return true;
        }
        // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:910:3
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$parseUnaliasedExpression(boolean scanToEnd) {
        if (hitFailure) return false;
        if (remainingLookahead <= 0) {
            return true;
        }
        // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:974:3
        // NonTerminal parseTerm5 at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:974:3
        pushOntoLookaheadStack("parseUnaliasedExpression", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 974, 3);
        currentLookaheadProduction = "parseTerm5";
        try {
            if (!check$parseTerm5(false)) return false;
        } finally {
            popLookaheadStack();
        }
        if (hitFailure) return false;
        if (remainingLookahead <= 0) {
            return true;
        }
        // Lookahead Code for ZeroOrMore specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:975:3
        boolean passedPredicate2832 = passedPredicate;
        try {
            while (remainingLookahead > 0 && !hitFailure) {
                Token token2833 = currentLookaheadToken;
                passedPredicate = false;
                if (!check$Grammer_ccc$976$5(false)) {
                    if (passedPredicate && !legacyGlitchyLookahead) return false;
                    currentLookaheadToken = token2833;
                    break;
                }
            }
        } finally {
            passedPredicate = passedPredicate2832;
        }
        hitFailure = false;
        if (hitFailure) return false;
        if (remainingLookahead <= 0) {
            return true;
        }
        // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1000:3
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$parseTerm5(boolean scanToEnd) {
        if (hitFailure) return false;
        if (remainingLookahead <= 0) {
            return true;
        }
        // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1010:3
        // NonTerminal parseTerm4 at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1010:3
        pushOntoLookaheadStack("parseTerm5", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1010, 3);
        currentLookaheadProduction = "parseTerm4";
        try {
            if (!check$parseTerm4(false)) return false;
        } finally {
            popLookaheadStack();
        }
        if (hitFailure) return false;
        if (remainingLookahead <= 0) {
            return true;
        }
        // Lookahead Code for ZeroOrMore specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1011:3
        boolean passedPredicate2838 = passedPredicate;
        try {
            while (remainingLookahead > 0 && !hitFailure) {
                Token token2839 = currentLookaheadToken;
                passedPredicate = false;
                if (!check$Grammer_ccc$1012$5(false)) {
                    if (passedPredicate && !legacyGlitchyLookahead) return false;
                    currentLookaheadToken = token2839;
                    break;
                }
            }
        } finally {
            passedPredicate = passedPredicate2838;
        }
        hitFailure = false;
        if (hitFailure) return false;
        if (remainingLookahead <= 0) {
            return true;
        }
        // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1020:3
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$parseTerm4(boolean scanToEnd) {
        if (hitFailure) return false;
        if (remainingLookahead <= 0) {
            return true;
        }
        // Lookahead Code for ExpansionChoice specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1030:3
        Token token2842 = currentLookaheadToken;
        int remainingLookahead2842 = remainingLookahead;
        boolean hitFailure2842 = hitFailure, passedPredicate2842 = passedPredicate;
        try {
            passedPredicate = false;
            if (!check$Grammer_ccc$1030$3(false)) {
                currentLookaheadToken = token2842;
                remainingLookahead = remainingLookahead2842;
                hitFailure = hitFailure2842;
                if (passedPredicate && !legacyGlitchyLookahead) return false;
                passedPredicate = false;
                if (!check$Grammer_ccc$1034$3(false)) {
                    currentLookaheadToken = token2842;
                    remainingLookahead = remainingLookahead2842;
                    hitFailure = hitFailure2842;
                    return false;
                }
            }
        } finally {
            passedPredicate = passedPredicate2842;
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$parseTerm3(boolean scanToEnd) {
        if (hitFailure) return false;
        if (remainingLookahead <= 0) {
            return true;
        }
        // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1049:3
        // NonTerminal parseTerm2 at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1049:3
        pushOntoLookaheadStack("parseTerm3", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1049, 3);
        currentLookaheadProduction = "parseTerm2";
        try {
            if (!check$parseTerm2(false)) return false;
        } finally {
            popLookaheadStack();
        }
        if (hitFailure) return false;
        if (remainingLookahead <= 0) {
            return true;
        }
        // Lookahead Code for ZeroOrMore specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1050:3
        boolean passedPredicate2846 = passedPredicate;
        try {
            while (remainingLookahead > 0 && !hitFailure) {
                Token token2847 = currentLookaheadToken;
                passedPredicate = false;
                if (!check$Grammer_ccc$1052$5(false)) {
                    if (passedPredicate && !legacyGlitchyLookahead) return false;
                    currentLookaheadToken = token2847;
                    break;
                }
            }
        } finally {
            passedPredicate = passedPredicate2846;
        }
        hitFailure = false;
        if (hitFailure) return false;
        if (remainingLookahead <= 0) {
            return true;
        }
        // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1151:3
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$parseTerm2(boolean scanToEnd) {
        if (hitFailure) return false;
        if (remainingLookahead <= 0) {
            return true;
        }
        // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1161:3
        // NonTerminal parseTerm at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1161:3
        pushOntoLookaheadStack("parseTerm2", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1161, 3);
        currentLookaheadProduction = "parseTerm";
        try {
            if (!check$parseTerm(false)) return false;
        } finally {
            popLookaheadStack();
        }
        if (hitFailure) return false;
        if (remainingLookahead <= 0) {
            return true;
        }
        // Lookahead Code for ZeroOrMore specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1162:3
        boolean passedPredicate2852 = passedPredicate;
        try {
            while (remainingLookahead > 0 && !hitFailure) {
                Token token2853 = currentLookaheadToken;
                passedPredicate = false;
                if (!check$Grammer_ccc$1163$5(false)) {
                    if (passedPredicate && !legacyGlitchyLookahead) return false;
                    currentLookaheadToken = token2853;
                    break;
                }
            }
        } finally {
            passedPredicate = passedPredicate2852;
        }
        hitFailure = false;
        if (hitFailure) return false;
        if (remainingLookahead <= 0) {
            return true;
        }
        // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1185:3
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$parseTerm(boolean scanToEnd) {
        if (hitFailure) return false;
        if (remainingLookahead <= 0) {
            return true;
        }
        // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1195:3
        // NonTerminal parseFactor at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1195:3
        pushOntoLookaheadStack("parseTerm", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1195, 3);
        currentLookaheadProduction = "parseFactor";
        try {
            if (!check$parseFactor(false)) return false;
        } finally {
            popLookaheadStack();
        }
        if (hitFailure) return false;
        if (remainingLookahead <= 0) {
            return true;
        }
        // Lookahead Code for ZeroOrMore specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1196:3
        boolean passedPredicate2858 = passedPredicate;
        try {
            while (remainingLookahead > 0 && !hitFailure) {
                Token token2859 = currentLookaheadToken;
                passedPredicate = false;
                if (!check$Grammer_ccc$1197$5(false)) {
                    if (passedPredicate && !legacyGlitchyLookahead) return false;
                    currentLookaheadToken = token2859;
                    break;
                }
            }
        } finally {
            passedPredicate = passedPredicate2858;
        }
        hitFailure = false;
        if (hitFailure) return false;
        if (remainingLookahead <= 0) {
            return true;
        }
        // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1212:3
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$parseFactor(boolean scanToEnd) {
        if (hitFailure) return false;
        if (remainingLookahead <= 0) {
            return true;
        }
        // Lookahead Code for ExpansionChoice specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1222:3
        Token token2862 = currentLookaheadToken;
        int remainingLookahead2862 = remainingLookahead;
        boolean hitFailure2862 = hitFailure, passedPredicate2862 = passedPredicate;
        try {
            passedPredicate = false;
            if (!check$Grammer_ccc$1222$3(false)) {
                currentLookaheadToken = token2862;
                remainingLookahead = remainingLookahead2862;
                hitFailure = hitFailure2862;
                if (passedPredicate && !legacyGlitchyLookahead) return false;
                passedPredicate = false;
                if (!check$Grammer_ccc$1226$3(false)) {
                    currentLookaheadToken = token2862;
                    remainingLookahead = remainingLookahead2862;
                    hitFailure = hitFailure2862;
                    if (passedPredicate && !legacyGlitchyLookahead) return false;
                    passedPredicate = false;
                    if (!check$Grammer_ccc$1230$3(false)) {
                        currentLookaheadToken = token2862;
                        remainingLookahead = remainingLookahead2862;
                        hitFailure = hitFailure2862;
                        if (passedPredicate && !legacyGlitchyLookahead) return false;
                        passedPredicate = false;
                        if (!check$Grammer_ccc$1237$3(false)) {
                            currentLookaheadToken = token2862;
                            remainingLookahead = remainingLookahead2862;
                            hitFailure = hitFailure2862;
                            return false;
                        }
                    }
                }
            }
        } finally {
            passedPredicate = passedPredicate2862;
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$parsePrimary(boolean scanToEnd) {
        if (hitFailure) return false;
        if (remainingLookahead <= 0) {
            return true;
        }
        // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1251:3
        // NonTerminal parseAtom at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1251:3
        pushOntoLookaheadStack("parsePrimary", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1251, 3);
        currentLookaheadProduction = "parseAtom";
        try {
            if (!check$parseAtom(false)) return false;
        } finally {
            popLookaheadStack();
        }
        if (hitFailure) return false;
        if (remainingLookahead <= 0) {
            return true;
        }
        // Lookahead Code for ZeroOrMore specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1252:3
        boolean passedPredicate2866 = passedPredicate;
        try {
            while (remainingLookahead > 0 && !hitFailure) {
                Token token2867 = currentLookaheadToken;
                passedPredicate = false;
                if (!check$Grammer_ccc$1253$5(false)) {
                    if (passedPredicate && !legacyGlitchyLookahead) return false;
                    currentLookaheadToken = token2867;
                    break;
                }
            }
        } finally {
            passedPredicate = passedPredicate2866;
        }
        hitFailure = false;
        if (hitFailure) return false;
        if (remainingLookahead <= 0) {
            return true;
        }
        // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1255:3
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$objectIdentifierOrFuncall(boolean scanToEnd) {
        if (hitFailure) return false;
        if (remainingLookahead <= 0) {
            return true;
        }
        // Lookahead Code for NonTerminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1266:3
        // NonTerminal parseIdentifier at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1266:3
        pushOntoLookaheadStack("objectIdentifierOrFuncall", "/home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc", 1266, 3);
        currentLookaheadProduction = "parseIdentifier";
        try {
            if (!check$parseIdentifier(false)) return false;
        } finally {
            popLookaheadStack();
        }
        if (hitFailure) return false;
        if (remainingLookahead <= 0) {
            return true;
        }
        // Lookahead Code for ZeroOrOne specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1267:3
        Token token2872 = currentLookaheadToken;
        boolean passedPredicate2872 = passedPredicate;
        passedPredicate = false;
        try {
            if (!check$Grammer_ccc$1268$5(false)) {
                if (passedPredicate && !legacyGlitchyLookahead) return false;
                currentLookaheadToken = token2872;
                hitFailure = false;
            }
        } finally {
            passedPredicate = passedPredicate2872;
        }
        if (hitFailure) return false;
        if (remainingLookahead <= 0) {
            return true;
        }
        // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1274:3
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$parseAtom(boolean scanToEnd) {
        if (hitFailure) return false;
        if (remainingLookahead <= 0) {
            return true;
        }
        // Lookahead Code for ExpansionChoice specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1302:3
        Token token2876 = currentLookaheadToken;
        int remainingLookahead2876 = remainingLookahead;
        boolean hitFailure2876 = hitFailure, passedPredicate2876 = passedPredicate;
        try {
            passedPredicate = false;
            if (!scanToken(SINGLE_QUOTED_STRING)) {
                currentLookaheadToken = token2876;
                remainingLookahead = remainingLookahead2876;
                hitFailure = hitFailure2876;
                if (passedPredicate && !legacyGlitchyLookahead) return false;
                passedPredicate = false;
                if (!scanToken(DOUBLE_QUOTED_STRING)) {
                    currentLookaheadToken = token2876;
                    remainingLookahead = remainingLookahead2876;
                    hitFailure = hitFailure2876;
                    if (passedPredicate && !legacyGlitchyLookahead) return false;
                    passedPredicate = false;
                    if (!scanToken(UNSIGNED_INTEGER_LITERAL, APPROX_NUMERIC_LITERAL, DECIMAL_NUMERIC_LITERAL)) {
                        currentLookaheadToken = token2876;
                        remainingLookahead = remainingLookahead2876;
                        hitFailure = hitFailure2876;
                        if (passedPredicate && !legacyGlitchyLookahead) return false;
                        passedPredicate = false;
                        if (!scanToken(NULL)) {
                            currentLookaheadToken = token2876;
                            remainingLookahead = remainingLookahead2876;
                            hitFailure = hitFailure2876;
                            if (passedPredicate && !legacyGlitchyLookahead) return false;
                            passedPredicate = false;
                            if (!check$Grammer_ccc$1318$3(false)) {
                                currentLookaheadToken = token2876;
                                remainingLookahead = remainingLookahead2876;
                                hitFailure = hitFailure2876;
                                if (passedPredicate && !legacyGlitchyLookahead) return false;
                                passedPredicate = false;
                                if (!check$Grammer_ccc$1328$3(false)) {
                                    currentLookaheadToken = token2876;
                                    remainingLookahead = remainingLookahead2876;
                                    hitFailure = hitFailure2876;
                                    if (passedPredicate && !legacyGlitchyLookahead) return false;
                                    passedPredicate = false;
                                    if (!check$Grammer_ccc$1337$3(false)) {
                                        currentLookaheadToken = token2876;
                                        remainingLookahead = remainingLookahead2876;
                                        hitFailure = hitFailure2876;
                                        if (passedPredicate && !legacyGlitchyLookahead) return false;
                                        passedPredicate = false;
                                        if (!check$Grammer_ccc$1351$3(false)) {
                                            currentLookaheadToken = token2876;
                                            remainingLookahead = remainingLookahead2876;
                                            hitFailure = hitFailure2876;
                                            if (passedPredicate && !legacyGlitchyLookahead) return false;
                                            passedPredicate = false;
                                            if (!check$Grammer_ccc$1358$3(false)) {
                                                currentLookaheadToken = token2876;
                                                remainingLookahead = remainingLookahead2876;
                                                hitFailure = hitFailure2876;
                                                return false;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        } finally {
            passedPredicate = passedPredicate2876;
        }
        return true;
    }

    // BuildProductionLookaheadMethod macro
    private final boolean check$parseCaseExpression(boolean scanToEnd) {
        if (hitFailure) return false;
        if (remainingLookahead <= 0) {
            return true;
        }
        // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1396:3
        if (!scanToken(CASE)) return false;
        if (hitFailure) return false;
        if (remainingLookahead <= 0) {
            return true;
        }
        // Lookahead Code for ZeroOrOne specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1397:3
        Token token2880 = currentLookaheadToken;
        boolean passedPredicate2880 = passedPredicate;
        passedPredicate = false;
        try {
            if (!check$Grammer_ccc$1398$5(false)) {
                if (passedPredicate && !legacyGlitchyLookahead) return false;
                currentLookaheadToken = token2880;
                hitFailure = false;
            }
        } finally {
            passedPredicate = passedPredicate2880;
        }
        if (hitFailure) return false;
        if (remainingLookahead <= 0) {
            return true;
        }
        // Lookahead Code for ZeroOrMore specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1404:3
        boolean passedPredicate2882 = passedPredicate;
        try {
            while (remainingLookahead > 0 && !hitFailure) {
                Token token2883 = currentLookaheadToken;
                passedPredicate = false;
                if (!check$Grammer_ccc$1405$5(false)) {
                    if (passedPredicate && !legacyGlitchyLookahead) return false;
                    currentLookaheadToken = token2883;
                    break;
                }
            }
        } finally {
            passedPredicate = passedPredicate2882;
        }
        hitFailure = false;
        if (hitFailure) return false;
        if (remainingLookahead <= 0) {
            return true;
        }
        // Lookahead Code for ZeroOrOne specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1411:3
        Token token2885 = currentLookaheadToken;
        boolean passedPredicate2885 = passedPredicate;
        passedPredicate = false;
        try {
            if (!check$Grammer_ccc$1412$5(false)) {
                if (passedPredicate && !legacyGlitchyLookahead) return false;
                currentLookaheadToken = token2885;
                hitFailure = false;
            }
        } finally {
            passedPredicate = passedPredicate2885;
        }
        if (hitFailure) return false;
        if (remainingLookahead <= 0) {
            return true;
        }
        // Lookahead Code for Terminal specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1417:3
        if (!scanToken(END)) return false;
        if (hitFailure) return false;
        if (remainingLookahead <= 0) {
            return true;
        }
        // Lookahead Code for CodeBlock specified at /home/stbischof/git/mondrian/mdx/parser.ccc/src/main/ccc/Grammer.ccc:1418:3
        return true;
    }

    private ArrayList<NonTerminalCall> parsingStack = new ArrayList<>();
    private ArrayList<NonTerminalCall> lookaheadStack = new ArrayList<>();

    private final void pushOntoCallStack(String methodName, String fileName, int line, int column) {
        parsingStack.add(new NonTerminalCall("MdxParser", token_source, fileName, methodName, line, column, null));
    }

    private final void popCallStack() {
        NonTerminalCall ntc = parsingStack.remove(parsingStack.size() - 1);
        this.currentlyParsedProduction = ntc.productionName;
    }

    private final void restoreCallStack(int prevSize) {
        while (parsingStack.size() > prevSize) {
            popCallStack();
        }
    }

    private final void pushOntoLookaheadStack(String methodName, String fileName, int line, int column) {
        lookaheadStack.add(new NonTerminalCall("MdxParser", token_source, fileName, methodName, line, column, null));
    }

    private final void popLookaheadStack() {
        NonTerminalCall ntc = lookaheadStack.remove(lookaheadStack.size() - 1);
        this.currentLookaheadProduction = ntc.productionName;
    }

    void dumpLookaheadStack(PrintStream ps) {
        ListIterator<NonTerminalCall> it = lookaheadStack.listIterator(lookaheadStack.size());
        while (it.hasPrevious()) {
            it.previous().dump(ps);
        }
    }

    void dumpCallStack(PrintStream ps) {
        ListIterator<NonTerminalCall> it = parsingStack.listIterator(parsingStack.size());
        while (it.hasPrevious()) {
            it.previous().dump(ps);
        }
    }

    void dumpLookaheadCallStack(PrintStream ps) {
        ps.println("Current Parser Production is: " + currentlyParsedProduction);
        ps.println("Current Lookahead Production is: " + currentLookaheadProduction);
        ps.println("---Lookahead Stack---");
        dumpLookaheadStack(ps);
        ps.println("---Call Stack---");
        dumpCallStack(ps);
    }

    public boolean isParserTolerant() {
        return false;
    }

    public void setParserTolerant(boolean tolerantParsing) {
        if (tolerantParsing) {
            throw new UnsupportedOperationException("This parser was not built with that feature!");
        }
    }

    private Token consumeToken(TokenType expectedType) {
        Token nextToken = nextToken(lastConsumedToken);
        if (nextToken.getType() != expectedType) {
            nextToken = handleUnexpectedTokenType(expectedType, nextToken);
        }
        this.lastConsumedToken = nextToken;
        this.nextTokenType = null;
        if (buildTree && tokensAreNodes) {
            pushNode(lastConsumedToken);
        }
        return lastConsumedToken;
    }

    private Token handleUnexpectedTokenType(TokenType expectedType, Token nextToken) {
        throw new ParseException(nextToken, EnumSet.of(expectedType), parsingStack);
    }


    private class ParseState {
        Token lastConsumed;
        ArrayList<NonTerminalCall> parsingStack;
        LexicalState lexicalState;
        NodeScope nodeScope;

        ParseState() {
            this.lastConsumed = MdxParser.this.lastConsumedToken;
            @SuppressWarnings("unchecked")
            ArrayList<NonTerminalCall> parsingStack = (ArrayList<NonTerminalCall>) MdxParser.this.parsingStack.clone();
            this.parsingStack = parsingStack;
            this.lexicalState = token_source.lexicalState;
            this.nodeScope = currentNodeScope.clone();
        }

    }

    private boolean buildTree = true;
    private boolean tokensAreNodes = true;
    private boolean unparsedTokensAreNodes = false;

    public boolean isTreeBuildingEnabled() {
        return buildTree;
    }

    public void setUnparsedTokensAreNodes(boolean unparsedTokensAreNodes) {
        this.unparsedTokensAreNodes = unparsedTokensAreNodes;
    }

    public void setTokensAreNodes(boolean tokensAreNodes) {
        this.tokensAreNodes = tokensAreNodes;
    }

    NodeScope currentNodeScope = new NodeScope();

    /**
    * @return the root node of the AST. It only makes sense to call
    * this after a successful parse.
    */
    public Node rootNode() {
        return currentNodeScope.rootNode();
    }

    /**
    * push a node onto the top of the node stack
    * @param n the node to push
    */
    public void pushNode(Node n) {
        currentNodeScope.add(n);
    }

    /**
    * @return the node on the top of the stack, and remove it from the
    * stack.
    */
    public Node popNode() {
        return currentNodeScope.pop();
    }

    /**
    * @return the node currently on the top of the tree-building stack.
    */
    public Node peekNode() {
        return currentNodeScope.peek();
    }

    /**
    * Puts the node on the top of the stack. However, unlike pushNode()
    * it replaces the node that is currently on the top of the stack.
    * This is effectively equivalent to popNode() followed by pushNode(n)
    * @param n the node to poke
    */
    public void pokeNode(Node n) {
        currentNodeScope.poke(n);
    }

    /**
    * @return the number of Nodes on the tree-building stack in the current node
    * scope.
    */
    public int nodeArity() {
        return currentNodeScope.size();
    }

    private void clearNodeScope() {
        currentNodeScope.clear();
    }

    private void openNodeScope(Node n) {
        new NodeScope();
        if (n != null) {
            Token next = nextToken(lastConsumedToken);
            n.setTokenSource(lastConsumedToken.getTokenSource());
            n.setBeginOffset(next.getBeginOffset());
            n.open();
        }
    }

    /* A definite node is constructed from a specified number of
    * children.  That number of nodes are popped from the stack and
    * made the children of the definite node.  Then the definite node
    * is pushed on to the stack.
    */
    private void closeNodeScope(Node n, int num) {
        n.setEndOffset(lastConsumedToken.getEndOffset());
        currentNodeScope.close();
        ArrayList<Node> nodes = new ArrayList<Node>();
        for (int i = 0; i < num; i++) {
            nodes.add(popNode());
        }
        Collections.reverse(nodes);
        for (Node child : nodes) {
            // FIXME deal with the UNPARSED_TOKENS_ARE_NODES case
            n.addChild(child);
        }
        n.close();
        pushNode(n);
    }

    /**
    * A conditional node is constructed if the condition is true.  All
    * the nodes that have been pushed since the node was opened are
    * made children of the conditional node, which is then pushed
    * on to the stack.  If the condition is false the node is not
    * constructed and they are left on the stack.
    */
    private void closeNodeScope(Node n, boolean condition) {
        if (n != null && condition) {
            n.setEndOffset(lastConsumedToken.getEndOffset());
            int a = nodeArity();
            currentNodeScope.close();
            ArrayList<Node> nodes = new ArrayList<Node>();
            while (a-- > 0) {
                nodes.add(popNode());
            }
            Collections.reverse(nodes);
            for (Node child : nodes) {
                if (unparsedTokensAreNodes && child instanceof Token) {
                    Token tok = (Token) child;
                    while (tok.previousCachedToken() != null && tok.previousCachedToken().isUnparsed()) {
                        tok = tok.previousCachedToken();
                    }
                    while (tok.isUnparsed()) {
                        n.addChild(tok);
                        tok = tok.nextCachedToken();
                    }
                }
                n.addChild(child);
            }
            n.close();
            pushNode(n);
        } else {
            currentNodeScope.close();
        }
    }

    public boolean getBuildTree() {
        return buildTree;
    }

    public void setBuildTree(boolean buildTree) {
        this.buildTree = buildTree;
    }


    @SuppressWarnings("serial")
    class NodeScope extends ArrayList<Node> {
        NodeScope parentScope;

        NodeScope() {
            this.parentScope = MdxParser.this.currentNodeScope;
            MdxParser.this.currentNodeScope = this;
        }

        boolean isRootScope() {
            return parentScope == null;
        }

        Node rootNode() {
            NodeScope ns = this;
            while (ns.parentScope != null) {
                ns = ns.parentScope;
            }
            return ns.isEmpty() ? null : ns.get(0);
        }

        Node peek() {
            if (isEmpty()) {
                return parentScope == null ? null : parentScope.peek();
            }
            return get(size() - 1);
        }

        Node pop() {
            return isEmpty() ? parentScope.pop() : remove(size() - 1);
        }

        void poke(Node n) {
            if (isEmpty()) {
                parentScope.poke(n);
            } else {
                set(size() - 1, n);
            }
        }

        void close() {
            parentScope.addAll(this);
            MdxParser.this.currentNodeScope = parentScope;
        }

        int nestingLevel() {
            int result = 0;
            NodeScope parent = this;
            while (parent.parentScope != null) {
                result++;
                parent = parent.parentScope;
            }
            return result;
        }

        public NodeScope clone() {
            NodeScope clone = (NodeScope) super.clone();
            if (parentScope != null) {
                clone.parentScope = parentScope.clone();
            }
            return clone;
        }

    }

}


